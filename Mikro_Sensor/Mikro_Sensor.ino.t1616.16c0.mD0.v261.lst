
C:\Users\XIRKA(~1\AppData\Local\Temp\arduino_build_295343/Mikro_Sensor.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
   0:	3f c0       	rjmp	.+126    	; 0x80 <__dtors_end>
   2:	00 00       	nop
../../../../crt1/gcrt1.S:67
   4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
   6:	00 00       	nop
../../../../crt1/gcrt1.S:68
   8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
   a:	00 00       	nop
../../../../crt1/gcrt1.S:69
   c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
   e:	00 00       	nop
../../../../crt1/gcrt1.S:70
  10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
  12:	00 00       	nop
../../../../crt1/gcrt1.S:71
  14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
  16:	00 00       	nop
../../../../crt1/gcrt1.S:72
  18:	64 c0       	rjmp	.+200    	; 0xe2 <__bad_interrupt>
  1a:	00 00       	nop
../../../../crt1/gcrt1.S:73
  1c:	62 c0       	rjmp	.+196    	; 0xe2 <__bad_interrupt>
  1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
  20:	60 c0       	rjmp	.+192    	; 0xe2 <__bad_interrupt>
  22:	00 00       	nop
../../../../crt1/gcrt1.S:75
  24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
  26:	00 00       	nop
../../../../crt1/gcrt1.S:76
  28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
  2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
  2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
  2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
  30:	58 c0       	rjmp	.+176    	; 0xe2 <__bad_interrupt>
  32:	00 00       	nop
../../../../crt1/gcrt1.S:79
  34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
  36:	00 00       	nop
../../../../crt1/gcrt1.S:80
  38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
  3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
  3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__vector_15>
  3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
  40:	50 c0       	rjmp	.+160    	; 0xe2 <__bad_interrupt>
  42:	00 00       	nop
../../../../crt1/gcrt1.S:83
  44:	4e c0       	rjmp	.+156    	; 0xe2 <__bad_interrupt>
  46:	00 00       	nop
../../../../crt1/gcrt1.S:84
  48:	4c c0       	rjmp	.+152    	; 0xe2 <__bad_interrupt>
  4a:	00 00       	nop
../../../../crt1/gcrt1.S:85
  4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
  4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
  50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
  52:	00 00       	nop
../../../../crt1/gcrt1.S:87
  54:	46 c0       	rjmp	.+140    	; 0xe2 <__bad_interrupt>
  56:	00 00       	nop
../../../../crt1/gcrt1.S:88
  58:	44 c0       	rjmp	.+136    	; 0xe2 <__bad_interrupt>
  5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
  5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
  5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
  60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
  62:	00 00       	nop
../../../../crt1/gcrt1.S:91
  64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
  66:	00 00       	nop
../../../../crt1/gcrt1.S:92
  68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
  6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
  6c:	9b c2       	rjmp	.+1334   	; 0x5a4 <__vector_27>
  6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
  70:	94 c2       	rjmp	.+1320   	; 0x59a <__vector_28>
  72:	00 00       	nop
../../../../crt1/gcrt1.S:95
  74:	9c c2       	rjmp	.+1336   	; 0x5ae <__vector_29>
  76:	00 00       	nop
../../../../crt1/gcrt1.S:96
  78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
	...

0000007c <__ctors_start>:
__trampolines_start():
  7c:	da 02       	muls	r29, r26

0000007e <__ctors_end>:
__dtors_start():
  7e:	a7 04       	cpc	r10, r7

00000080 <__dtors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
  80:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
  82:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
  84:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
  86:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
  88:	df e3       	ldi	r29, 0x3F	; 63
../../../../crt1/gcrt1.S:237
  8a:	de bf       	out	0x3e, r29	; 62

0000008c <_initThreeStuff()>:
init_reset_flags():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/main.cpp:100

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
  8c:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <vtable for HardwareSerial+0x7f71cc>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/main.cpp:101
    RSTCTRL.RSTFR = flags;
  90:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <vtable for HardwareSerial+0x7f71cc>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/main.cpp:102
    if (flags == 0) {
  94:	81 11       	cpse	r24, r1
  96:	05 c0       	rjmp	.+10     	; 0xa2 <_initThreeStuff()+0x16>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/main.cpp:103
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
  98:	98 ed       	ldi	r25, 0xD8	; 216
  9a:	21 e0       	ldi	r18, 0x01	; 1
  9c:	94 bf       	out	0x34, r25	; 52
  9e:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <vtable for HardwareSerial+0x7f71cd>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/main.cpp:105
    }
    GPIOR0 = flags;
  a2:	8c bb       	out	0x1c, r24	; 28

000000a4 <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  a4:	29 e3       	ldi	r18, 0x39	; 57
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  a6:	a6 e0       	ldi	r26, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  a8:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  aa:	01 c0       	rjmp	.+2      	; 0xae <.do_clear_bss_start>

000000ac <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  ac:	1d 92       	st	X+, r1

000000ae <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  ae:	a9 32       	cpi	r26, 0x29	; 41
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  b0:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  b2:	e1 f7       	brne	.-8      	; 0xac <.do_clear_bss_loop>

000000b4 <__do_copy_data>:
__do_copy_data():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  b4:	18 e3       	ldi	r17, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  b6:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  b8:	b8 e3       	ldi	r27, 0x38	; 56
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  ba:	e7 e8       	ldi	r30, 0x87	; 135
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  bc:	fe e0       	ldi	r31, 0x0E	; 14
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  be:	02 c0       	rjmp	.+4      	; 0xc4 <__do_copy_data+0x10>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  c0:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  c2:	0d 92       	st	X+, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  c4:	a6 30       	cpi	r26, 0x06	; 6
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  c6:	b1 07       	cpc	r27, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  c8:	d9 f7       	brne	.-10     	; 0xc0 <__do_copy_data+0xc>

000000ca <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  ca:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  cc:	cf e3       	ldi	r28, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  ce:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  d0:	03 c0       	rjmp	.+6      	; 0xd8 <__do_global_ctors+0xe>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  d2:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  d4:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  d6:	b6 d4       	rcall	.+2412   	; 0xa44 <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  d8:	ce 33       	cpi	r28, 0x3E	; 62
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  da:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  dc:	d1 f7       	brne	.-12     	; 0xd2 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
  de:	c0 d2       	rcall	.+1408   	; 0x660 <main>
../../../../crt1/gcrt1.S:315
  e0:	a2 c6       	rjmp	.+3396   	; 0xe26 <__do_global_dtors>

000000e2 <__bad_interrupt>:
__vector_22():
  e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <HardwareSerial::availableForWrite()>:
availableForWrite():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:662
      int HardwareSerial::availableForWrite(void) {
        tx_buffer_index_t head;
        tx_buffer_index_t tail;

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
  e4:	fc 01       	movw	r30, r24
  e6:	57 85       	ldd	r21, Z+15	; 0x0f
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:663
          tail = _tx_buffer_tail;
  e8:	40 89       	ldd	r20, Z+16	; 0x10
  ea:	25 2f       	mov	r18, r21
  ec:	30 e0       	ldi	r19, 0x00	; 0
  ee:	84 2f       	mov	r24, r20
  f0:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:666
        }
        if (head >= tail) {
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  f2:	82 1b       	sub	r24, r18
  f4:	93 0b       	sbc	r25, r19
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:665

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
          tail = _tx_buffer_tail;
        }
        if (head >= tail) {
  f6:	54 17       	cp	r21, r20
  f8:	10 f0       	brcs	.+4      	; 0xfe <HardwareSerial::availableForWrite()+0x1a>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:666
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  fa:	cf 96       	adiw	r24, 0x3f	; 63
  fc:	08 95       	ret
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:668
        }
        return tail - head - 1;
  fe:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:669
      }
 100:	08 95       	ret

00000102 <HardwareSerial::read()>:
read():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:646
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }

    int HardwareSerial::read(void) {
 102:	fc 01       	movw	r30, r24
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:648
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
 104:	95 85       	ldd	r25, Z+13	; 0x0d
 106:	86 85       	ldd	r24, Z+14	; 0x0e
 108:	98 17       	cp	r25, r24
 10a:	61 f0       	breq	.+24     	; 0x124 <HardwareSerial::read()+0x22>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:651
        return -1;
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
 10c:	a6 85       	ldd	r26, Z+14	; 0x0e
 10e:	ae 0f       	add	r26, r30
 110:	bf 2f       	mov	r27, r31
 112:	b1 1d       	adc	r27, r1
 114:	51 96       	adiw	r26, 0x11	; 17
 116:	8c 91       	ld	r24, X
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:652
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
 118:	96 85       	ldd	r25, Z+14	; 0x0e
 11a:	9f 5f       	subi	r25, 0xFF	; 255
 11c:	9f 73       	andi	r25, 0x3F	; 63
 11e:	96 87       	std	Z+14, r25	; 0x0e
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:653
        return c;
 120:	90 e0       	ldi	r25, 0x00	; 0
 122:	08 95       	ret
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:649
    }

    int HardwareSerial::read(void) {
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
 124:	8f ef       	ldi	r24, 0xFF	; 255
 126:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:655
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
        return c;
      }
    }
 128:	08 95       	ret

0000012a <HardwareSerial::peek()>:
peek():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:638

    int HardwareSerial::available(void) {
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
 12a:	fc 01       	movw	r30, r24
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:639
      if (_rx_buffer_head == _rx_buffer_tail) {
 12c:	95 85       	ldd	r25, Z+13	; 0x0d
 12e:	86 85       	ldd	r24, Z+14	; 0x0e
 130:	98 17       	cp	r25, r24
 132:	31 f0       	breq	.+12     	; 0x140 <HardwareSerial::peek()+0x16>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:642
        return -1;
      } else {
        return _rx_buffer[_rx_buffer_tail];
 134:	86 85       	ldd	r24, Z+14	; 0x0e
 136:	e8 0f       	add	r30, r24
 138:	f1 1d       	adc	r31, r1
 13a:	81 89       	ldd	r24, Z+17	; 0x11
 13c:	90 e0       	ldi	r25, 0x00	; 0
 13e:	08 95       	ret
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:640
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
 140:	8f ef       	ldi	r24, 0xFF	; 255
 142:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:644
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }
 144:	08 95       	ret

00000146 <HardwareSerial::available()>:
available():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:634
      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
    }

    int HardwareSerial::available(void) {
 146:	fc 01       	movw	r30, r24
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:635
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
 148:	95 85       	ldd	r25, Z+13	; 0x0d
 14a:	26 85       	ldd	r18, Z+14	; 0x0e
 14c:	89 2f       	mov	r24, r25
 14e:	90 e0       	ldi	r25, 0x00	; 0
 150:	80 5c       	subi	r24, 0xC0	; 192
 152:	9f 4f       	sbci	r25, 0xFF	; 255
 154:	82 1b       	sub	r24, r18
 156:	91 09       	sbc	r25, r1
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:636
    }
 158:	8f 73       	andi	r24, 0x3F	; 63
 15a:	99 27       	eor	r25, r25
 15c:	08 95       	ret

0000015e <HardwareSerial::_poll_tx_data_empty()>:
_poll_tx_data_empty():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:367
        HardwareSerial._tx_buffer_tail = txTail;
      }
    #endif

    // To invoke data empty "interrupt" via a call, use this method
    void HardwareSerial::_poll_tx_data_empty(void) {
 15e:	dc 01       	movw	r26, r24
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:368
      if ((!(SREG & CPU_I_bm)) ||  CPUINT.STATUS) {
 160:	0f b6       	in	r0, 0x3f	; 63
 162:	07 fe       	sbrs	r0, 7
 164:	04 c0       	rjmp	.+8      	; 0x16e <HardwareSerial::_poll_tx_data_empty()+0x10>
 166:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <vtable for HardwareSerial+0x7f729d>
 16a:	88 23       	and	r24, r24
 16c:	b1 f0       	breq	.+44     	; 0x19a <_poll_dre_done>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:385
        // so we'll have to poll the "data register empty" flag ourselves.
        // If it is set, pretend an interrupt has happened and call the handler
        // to free up space for us.
        // -Spence 10/23/20
        // Invoke interrupt handler only if conditions data register is empty
        if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
 16e:	18 96       	adiw	r26, 0x08	; 8
 170:	ed 91       	ld	r30, X+
 172:	fc 91       	ld	r31, X
 174:	19 97       	sbiw	r26, 0x09	; 9
 176:	84 81       	ldd	r24, Z+4	; 0x04
 178:	85 ff       	sbrs	r24, 5
 17a:	0f c0       	rjmp	.+30     	; 0x19a <_poll_dre_done>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:386
          if (_tx_buffer_head == _tx_buffer_tail) {
 17c:	1f 96       	adiw	r26, 0x0f	; 15
 17e:	9c 91       	ld	r25, X
 180:	1f 97       	sbiw	r26, 0x0f	; 15
 182:	50 96       	adiw	r26, 0x10	; 16
 184:	8c 91       	ld	r24, X
 186:	98 13       	cpse	r25, r24
 188:	04 c0       	rjmp	.+8      	; 0x192 <HardwareSerial::_poll_tx_data_empty()+0x34>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:388
            // Buffer empty, so disable "data register empty" interrupt
            (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
 18a:	85 81       	ldd	r24, Z+5	; 0x05
 18c:	8f 7d       	andi	r24, 0xDF	; 223
 18e:	85 83       	std	Z+5, r24	; 0x05
 190:	08 95       	ret
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:412
      #ifdef USART1
                    ::"z"((uint16_t)thisSerial)
      #else
                    ::"z"(&Serial0)
      #endif
                    : "r18","r19","r24","r25","r26","r27"); // these got saved and restored in the ISR context, but here we don't need top and in many cases no action is needed.
 192:	ec e1       	ldi	r30, 0x1C	; 28
 194:	f8 e3       	ldi	r31, 0x38	; 56
 196:	e8 94       	clt
 198:	3f c1       	rjmp	.+638    	; 0x418 <_poll_dre>

0000019a <_poll_dre_done>:
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:421
        }
      }
      // In case interrupts are enabled, the interrupt routine will be invoked by itself
      // Note that this currently does not handle cases where the DRE interruopt becomes
      // disabled, yet you are actually attempting to send. I don't think it can happen.
    }
 19a:	08 95       	ret

0000019c <HardwareSerial::write(unsigned char)>:
write():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:702
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }


      size_t HardwareSerial::write(uint8_t c) {
 19c:	0f 93       	push	r16
 19e:	1f 93       	push	r17
 1a0:	cf 93       	push	r28
 1a2:	df 93       	push	r29
 1a4:	ec 01       	movw	r28, r24
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:703
        _state |= 1; // Record that we have written to serial since it was begun.
 1a6:	8c 85       	ldd	r24, Y+12	; 0x0c
 1a8:	98 2f       	mov	r25, r24
 1aa:	91 60       	ori	r25, 0x01	; 1
 1ac:	9c 87       	std	Y+12, r25	; 0x0c
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:708
        // If the buffer and the data register is empty, just write the byte
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
 1ae:	2f 85       	ldd	r18, Y+15	; 0x0f
 1b0:	98 89       	ldd	r25, Y+16	; 0x10
 1b2:	29 13       	cpse	r18, r25
 1b4:	0a c0       	rjmp	.+20     	; 0x1ca <HardwareSerial::write(unsigned char)+0x2e>
 1b6:	e8 85       	ldd	r30, Y+8	; 0x08
 1b8:	f9 85       	ldd	r31, Y+9	; 0x09
 1ba:	94 81       	ldd	r25, Z+4	; 0x04
 1bc:	95 ff       	sbrs	r25, 5
 1be:	05 c0       	rjmp	.+10     	; 0x1ca <HardwareSerial::write(unsigned char)+0x2e>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:709
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
 1c0:	81 fd       	sbrc	r24, 1
 1c2:	0d c0       	rjmp	.+26     	; 0x1de <HardwareSerial::write(unsigned char)+0x42>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:716
            ctrla &= ~USART_RXCIE_bm;
            ctrla |=  USART_TXCIE_bm;
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
            (*_hwserial_module).CTRLA = ctrla;
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
 1c4:	80 e4       	ldi	r24, 0x40	; 64
 1c6:	84 83       	std	Z+4, r24	; 0x04
 1c8:	12 c0       	rjmp	.+36     	; 0x1ee <HardwareSerial::write(unsigned char)+0x52>
 1ca:	06 2f       	mov	r16, r22
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:734
           * // that the interrupt handler is called in this situation
           * (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
           */
          return 1;
        }
        tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  // % SERIAL_TX_BUFFER_SIZE;
 1cc:	1f 85       	ldd	r17, Y+15	; 0x0f
 1ce:	1f 5f       	subi	r17, 0xFF	; 255
 1d0:	1f 73       	andi	r17, 0x3F	; 63
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:738

        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
 1d2:	88 89       	ldd	r24, Y+16	; 0x10
 1d4:	81 13       	cpse	r24, r17
 1d6:	15 c0       	rjmp	.+42     	; 0x202 <HardwareSerial::write(unsigned char)+0x66>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:739
          _poll_tx_data_empty();
 1d8:	ce 01       	movw	r24, r28
 1da:	c1 df       	rcall	.-126    	; 0x15e <HardwareSerial::_poll_tx_data_empty()>
 1dc:	fa cf       	rjmp	.-12     	; 0x1d2 <HardwareSerial::write(unsigned char)+0x36>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:710
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
            uint8_t ctrla = (*_hwserial_module).CTRLA;
 1de:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:711
            ctrla &= ~USART_RXCIE_bm;
 1e0:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:712
            ctrla |=  USART_TXCIE_bm;
 1e2:	80 64       	ori	r24, 0x40	; 64
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:713
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
 1e4:	90 e4       	ldi	r25, 0x40	; 64
 1e6:	94 83       	std	Z+4, r25	; 0x04
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:714
            (*_hwserial_module).CTRLA = ctrla;
 1e8:	e8 85       	ldd	r30, Y+8	; 0x08
 1ea:	f9 85       	ldd	r31, Y+9	; 0x09
 1ec:	85 83       	std	Z+5, r24	; 0x05
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:719
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
          }
          // MUST clear TXCIF **before** writing new char, otherwise ill-timed interrupt can cause it to erase the flag after the new charchter has been sent!
          (*_hwserial_module).TXDATAL = c;
 1ee:	e8 85       	ldd	r30, Y+8	; 0x08
 1f0:	f9 85       	ldd	r31, Y+9	; 0x09
 1f2:	62 83       	std	Z+2, r22	; 0x02
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:754
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
        }
        return 1;
      }
 1f4:	81 e0       	ldi	r24, 0x01	; 1
 1f6:	90 e0       	ldi	r25, 0x00	; 0
 1f8:	df 91       	pop	r29
 1fa:	cf 91       	pop	r28
 1fc:	1f 91       	pop	r17
 1fe:	0f 91       	pop	r16
 200:	08 95       	ret
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:741
        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
          _poll_tx_data_empty();
        }
        _tx_buffer[_tx_buffer_head] = c;
 202:	ef 85       	ldd	r30, Y+15	; 0x0f
 204:	ec 0f       	add	r30, r28
 206:	fd 2f       	mov	r31, r29
 208:	f1 1d       	adc	r31, r1
 20a:	ef 5a       	subi	r30, 0xAF	; 175
 20c:	ff 4f       	sbci	r31, 0xFF	; 255
 20e:	00 83       	st	Z, r16
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:742
        _tx_buffer_head = i;
 210:	1f 87       	std	Y+15, r17	; 0x0f
 212:	e8 85       	ldd	r30, Y+8	; 0x08
 214:	f9 85       	ldd	r31, Y+9	; 0x09
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:743
        if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
 216:	8c 85       	ldd	r24, Y+12	; 0x0c
 218:	81 ff       	sbrs	r24, 1
 21a:	09 c0       	rjmp	.+18     	; 0x22e <HardwareSerial::write(unsigned char)+0x92>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:744
          uint8_t ctrla = (*_hwserial_module).CTRLA;
 21c:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:745
          ctrla &= ~USART_RXCIE_bm;
 21e:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:746
          ctrla |= USART_TXCIE_bm | USART_DREIE_bm;
 220:	80 66       	ori	r24, 0x60	; 96
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:747
          (*_hwserial_module).STATUS = USART_TXCIF_bm;
 222:	90 e4       	ldi	r25, 0x40	; 64
 224:	94 83       	std	Z+4, r25	; 0x04
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:748
          (*_hwserial_module).CTRLA = ctrla;
 226:	e8 85       	ldd	r30, Y+8	; 0x08
 228:	f9 85       	ldd	r31, Y+9	; 0x09
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:751
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
 22a:	85 83       	std	Z+5, r24	; 0x05
 22c:	e3 cf       	rjmp	.-58     	; 0x1f4 <HardwareSerial::write(unsigned char)+0x58>
 22e:	85 81       	ldd	r24, Z+5	; 0x05
 230:	80 62       	ori	r24, 0x20	; 32
 232:	fb cf       	rjmp	.-10     	; 0x22a <HardwareSerial::write(unsigned char)+0x8e>

00000234 <HardwareSerial::flush()>:
flush():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:671
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
        }
        return tail - head - 1;
      }

      void HardwareSerial::flush() {
 234:	cf 93       	push	r28
 236:	df 93       	push	r29
 238:	ec 01       	movw	r28, r24
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:675
        // If we have never written a byte, no need to flush. This special
        // case is needed since there is no way to force the TXCIF (transmit
        // complete) bit to 1 during initialization
        if (!_state & 1) {
 23a:	8c 85       	ldd	r24, Y+12	; 0x0c
 23c:	88 23       	and	r24, r24
 23e:	59 f0       	breq	.+22     	; 0x256 <HardwareSerial::flush()+0x22>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:690
        // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
        // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
        // and in that case flush(), and write() with full buffer would just straight up hang...

        // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
        while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
 240:	e8 85       	ldd	r30, Y+8	; 0x08
 242:	f9 85       	ldd	r31, Y+9	; 0x09
 244:	85 81       	ldd	r24, Z+5	; 0x05
 246:	85 fd       	sbrc	r24, 5
 248:	03 c0       	rjmp	.+6      	; 0x250 <HardwareSerial::flush()+0x1c>
 24a:	84 81       	ldd	r24, Z+4	; 0x04
 24c:	86 fd       	sbrc	r24, 6
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:695

          // If interrupts are globally disabled or the and DR empty interrupt is disabled,
          // poll the "data register empty" interrupt flag to prevent deadlock

          _poll_tx_data_empty();
 24e:	03 c0       	rjmp	.+6      	; 0x256 <HardwareSerial::flush()+0x22>
 250:	ce 01       	movw	r24, r28
 252:	85 df       	rcall	.-246    	; 0x15e <HardwareSerial::_poll_tx_data_empty()>
 254:	f5 cf       	rjmp	.-22     	; 0x240 <HardwareSerial::flush()+0xc>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:699
        }
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }
 256:	df 91       	pop	r29
 258:	cf 91       	pop	r28
 25a:	08 95       	ret

0000025c <String::StringIfHelper() const>:
StringIfHelper():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.h:56
class String {
    // use a function pointer to allow for "if (s)" without the
    // complications of an operator bool(). for more information, see:
    // http://www.artima.com/cppsource/safebool.html
    typedef void (String::*StringIfHelperType)() const;
    void StringIfHelper() const {}
 25c:	08 95       	ret

0000025e <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
 25e:	af 92       	push	r10
 260:	bf 92       	push	r11
 262:	cf 92       	push	r12
 264:	df 92       	push	r13
 266:	ef 92       	push	r14
 268:	ff 92       	push	r15
 26a:	0f 93       	push	r16
 26c:	1f 93       	push	r17
 26e:	cf 93       	push	r28
 270:	df 93       	push	r29
 272:	6c 01       	movw	r12, r24
 274:	7b 01       	movw	r14, r22
 276:	8b 01       	movw	r16, r22
 278:	04 0f       	add	r16, r20
 27a:	15 1f       	adc	r17, r21
 27c:	eb 01       	movw	r28, r22
 27e:	5e 01       	movw	r10, r28
 280:	ae 18       	sub	r10, r14
 282:	bf 08       	sbc	r11, r15
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/Print.cpp:31
  size_t n = 0;
  while (size--) {
 284:	c0 17       	cp	r28, r16
 286:	d1 07       	cpc	r29, r17
 288:	59 f0       	breq	.+22     	; 0x2a0 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/Print.cpp:32
    if (write(*buffer++)) {
 28a:	69 91       	ld	r22, Y+
 28c:	d6 01       	movw	r26, r12
 28e:	ed 91       	ld	r30, X+
 290:	fc 91       	ld	r31, X
 292:	01 90       	ld	r0, Z+
 294:	f0 81       	ld	r31, Z
 296:	e0 2d       	mov	r30, r0
 298:	c6 01       	movw	r24, r12
 29a:	09 95       	icall
 29c:	89 2b       	or	r24, r25
 29e:	79 f7       	brne	.-34     	; 0x27e <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
 2a0:	c5 01       	movw	r24, r10
 2a2:	df 91       	pop	r29
 2a4:	cf 91       	pop	r28
 2a6:	1f 91       	pop	r17
 2a8:	0f 91       	pop	r16
 2aa:	ff 90       	pop	r15
 2ac:	ef 90       	pop	r14
 2ae:	df 90       	pop	r13
 2b0:	cf 90       	pop	r12
 2b2:	bf 90       	pop	r11
 2b4:	af 90       	pop	r10
 2b6:	08 95       	ret

000002b8 <String::String(char)>:
__base_ctor ():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:58
  init();
  move(rval);
}
#endif

String::String(char c) {
 2b8:	cf 92       	push	r12
 2ba:	df 92       	push	r13
 2bc:	ef 92       	push	r14
 2be:	ff 92       	push	r15
 2c0:	0f 93       	push	r16
 2c2:	1f 93       	push	r17
 2c4:	cf 93       	push	r28
 2c6:	df 93       	push	r29
 2c8:	00 d0       	rcall	.+0      	; 0x2ca <String::String(char)+0x12>
 2ca:	cd b7       	in	r28, 0x3d	; 61
 2cc:	de b7       	in	r29, 0x3e	; 62
 2ce:	8c 01       	movw	r16, r24
_ZN6String4initEv():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:122
/*********************************************/
/*  Memory Management                        */
/*********************************************/

inline void String::init(void) {
  buffer = NULL;
 2d0:	fc 01       	movw	r30, r24
 2d2:	10 82       	st	Z, r1
 2d4:	11 82       	std	Z+1, r1	; 0x01
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:123
  capacity = 0;
 2d6:	12 82       	std	Z+2, r1	; 0x02
 2d8:	13 82       	std	Z+3, r1	; 0x03
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:124
  len = 0;
 2da:	14 82       	std	Z+4, r1	; 0x04
 2dc:	15 82       	std	Z+5, r1	; 0x05
__base_ctor ():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:61
#endif

String::String(char c) {
  init();
  char buf[2];
  buf[0] = c;
 2de:	69 83       	std	Y+1, r22	; 0x01
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:62
  buf[1] = 0;
 2e0:	1a 82       	std	Y+2, r1	; 0x02
operator=():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:235
}
#endif

String &String::operator = (const char *cstr) {
  if (cstr) {
    copy(cstr, strlen(cstr));
 2e2:	ce 01       	movw	r24, r28
 2e4:	01 96       	adiw	r24, 0x01	; 1
 2e6:	6c 01       	movw	r12, r24
 2e8:	fc 01       	movw	r30, r24
 2ea:	01 90       	ld	r0, Z+
 2ec:	00 20       	and	r0, r0
 2ee:	e9 f7       	brne	.-6      	; 0x2ea <String::String(char)+0x32>
 2f0:	31 97       	sbiw	r30, 0x01	; 1
 2f2:	7f 01       	movw	r14, r30
 2f4:	e8 1a       	sub	r14, r24
 2f6:	f9 0a       	sbc	r15, r25
changeBuffer():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:149
  }
  return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen) {
  char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 2f8:	b7 01       	movw	r22, r14
 2fa:	6f 5f       	subi	r22, 0xFF	; 255
 2fc:	7f 4f       	sbci	r23, 0xFF	; 255
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	80 e0       	ldi	r24, 0x00	; 0
 302:	cb d4       	rcall	.+2454   	; 0xc9a <realloc>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:151
  if (newbuffer) {
    buffer = newbuffer;
 304:	f8 01       	movw	r30, r16
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:150
  return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen) {
  char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
  if (newbuffer) {
 306:	00 97       	sbiw	r24, 0x00	; 0
 308:	91 f0       	breq	.+36     	; 0x32e <String::String(char)+0x76>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:151
    buffer = newbuffer;
 30a:	80 83       	st	Z, r24
 30c:	91 83       	std	Z+1, r25	; 0x01
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:152
    capacity = maxStrLen;
 30e:	e2 82       	std	Z+2, r14	; 0x02
 310:	f3 82       	std	Z+3, r15	; 0x03
reserve():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:140
unsigned char String::reserve(unsigned int size) {
  if (buffer && capacity >= size) {
    return 1;
  }
  if (changeBuffer(size)) {
    if (len == 0) {
 312:	24 81       	ldd	r18, Z+4	; 0x04
 314:	35 81       	ldd	r19, Z+5	; 0x05
 316:	23 2b       	or	r18, r19
 318:	11 f4       	brne	.+4      	; 0x31e <String::String(char)+0x66>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:141
      buffer[0] = 0;
 31a:	fc 01       	movw	r30, r24
 31c:	10 82       	st	Z, r1
copy():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:167
String &String::copy(const char *cstr, unsigned int length) {
  if (!reserve(length)) {
    invalidate();
    return *this;
  }
  len = length;
 31e:	f8 01       	movw	r30, r16
 320:	e4 82       	std	Z+4, r14	; 0x04
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:168
  strcpy(buffer, cstr);
 322:	f5 82       	std	Z+5, r15	; 0x05
 324:	b6 01       	movw	r22, r12
 326:	80 81       	ld	r24, Z
 328:	91 81       	ldd	r25, Z+1	; 0x01
 32a:	76 d5       	rcall	.+2796   	; 0xe18 <strcpy>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:128
  capacity = 0;
  len = 0;
}

void String::invalidate(void) {
  if (buffer) {
 32c:	0c c0       	rjmp	.+24     	; 0x346 <String::String(char)+0x8e>
invalidate():
 32e:	80 81       	ld	r24, Z
 330:	91 81       	ldd	r25, Z+1	; 0x01
 332:	00 97       	sbiw	r24, 0x00	; 0
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:129
    free(buffer);
 334:	09 f0       	breq	.+2      	; 0x338 <String::String(char)+0x80>
 336:	28 d4       	rcall	.+2128   	; 0xb88 <free>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:131
  }
  buffer = NULL;
 338:	f8 01       	movw	r30, r16
 33a:	10 82       	st	Z, r1
 33c:	11 82       	std	Z+1, r1	; 0x01
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:132
  capacity = len = 0;
 33e:	14 82       	std	Z+4, r1	; 0x04
 340:	15 82       	std	Z+5, r1	; 0x05
 342:	12 82       	std	Z+2, r1	; 0x02
 344:	13 82       	std	Z+3, r1	; 0x03
__base_ctor ():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:64
  init();
  char buf[2];
  buf[0] = c;
  buf[1] = 0;
  *this = buf;
}
 346:	0f 90       	pop	r0
 348:	0f 90       	pop	r0
 34a:	df 91       	pop	r29
 34c:	cf 91       	pop	r28
 34e:	1f 91       	pop	r17
 350:	0f 91       	pop	r16
 352:	ff 90       	pop	r15
 354:	ef 90       	pop	r14
 356:	df 90       	pop	r13
 358:	cf 90       	pop	r12
 35a:	08 95       	ret

0000035c <String::move(String&)>:
move():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:183
  strcpy_P(buffer, (PGM_P)pstr);
  return *this;
}

#if __cplusplus >= 201103L || defined(__GXX_EXPERIMENTAL_CXX0X__)
void String::move(String &rhs) {
 35c:	0f 93       	push	r16
 35e:	1f 93       	push	r17
 360:	cf 93       	push	r28
 362:	df 93       	push	r29
 364:	8c 01       	movw	r16, r24
 366:	eb 01       	movw	r28, r22
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:184
  if (buffer) {
 368:	fc 01       	movw	r30, r24
 36a:	80 81       	ld	r24, Z
 36c:	91 81       	ldd	r25, Z+1	; 0x01
 36e:	00 97       	sbiw	r24, 0x00	; 0
 370:	d1 f0       	breq	.+52     	; 0x3a6 <String::move(String&)+0x4a>
 372:	68 81       	ld	r22, Y
 374:	79 81       	ldd	r23, Y+1	; 0x01
_ZNK6StringcvMS_KFvvEEv.isra.0():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.h:179
    friend StringSumHelper &operator + (const StringSumHelper &lhs, double num);
    friend StringSumHelper &operator + (const StringSumHelper &lhs, const __FlashStringHelper *rhs);

    // comparison (only works w/ Strings and "strings")
    operator StringIfHelperType() const {
      return buffer ? &String::StringIfHelper : 0;
 376:	61 15       	cp	r22, r1
 378:	71 05       	cpc	r23, r1
 37a:	a1 f0       	breq	.+40     	; 0x3a4 <String::move(String&)+0x48>
move():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:185
    if (rhs && capacity >= rhs.len) {
 37c:	42 81       	ldd	r20, Z+2	; 0x02
 37e:	53 81       	ldd	r21, Z+3	; 0x03
 380:	2c 81       	ldd	r18, Y+4	; 0x04
 382:	3d 81       	ldd	r19, Y+5	; 0x05
 384:	42 17       	cp	r20, r18
 386:	53 07       	cpc	r21, r19
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:186
      strcpy(buffer, rhs.buffer);
 388:	68 f0       	brcs	.+26     	; 0x3a4 <String::move(String&)+0x48>
 38a:	46 d5       	rcall	.+2700   	; 0xe18 <strcpy>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:187
      len = rhs.len;
 38c:	8c 81       	ldd	r24, Y+4	; 0x04
 38e:	9d 81       	ldd	r25, Y+5	; 0x05
 390:	f8 01       	movw	r30, r16
 392:	84 83       	std	Z+4, r24	; 0x04
 394:	95 83       	std	Z+5, r25	; 0x05
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:199
  buffer = rhs.buffer;
  capacity = rhs.capacity;
  len = rhs.len;
  rhs.buffer = NULL;
  rhs.capacity = 0;
  rhs.len = 0;
 396:	1c 82       	std	Y+4, r1	; 0x04
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:200
}
 398:	1d 82       	std	Y+5, r1	; 0x05
 39a:	df 91       	pop	r29
 39c:	cf 91       	pop	r28
 39e:	1f 91       	pop	r17
 3a0:	0f 91       	pop	r16
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:191
      strcpy(buffer, rhs.buffer);
      len = rhs.len;
      rhs.len = 0;
      return;
    } else {
      free(buffer);
 3a2:	08 95       	ret
 3a4:	f1 d3       	rcall	.+2018   	; 0xb88 <free>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:194
    }
  }
  buffer = rhs.buffer;
 3a6:	88 81       	ld	r24, Y
 3a8:	99 81       	ldd	r25, Y+1	; 0x01
 3aa:	f8 01       	movw	r30, r16
 3ac:	80 83       	st	Z, r24
 3ae:	91 83       	std	Z+1, r25	; 0x01
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:195
  capacity = rhs.capacity;
 3b0:	8a 81       	ldd	r24, Y+2	; 0x02
 3b2:	9b 81       	ldd	r25, Y+3	; 0x03
 3b4:	82 83       	std	Z+2, r24	; 0x02
 3b6:	93 83       	std	Z+3, r25	; 0x03
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:196
  len = rhs.len;
 3b8:	8c 81       	ldd	r24, Y+4	; 0x04
 3ba:	9d 81       	ldd	r25, Y+5	; 0x05
 3bc:	84 83       	std	Z+4, r24	; 0x04
 3be:	95 83       	std	Z+5, r25	; 0x05
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:197
  rhs.buffer = NULL;
 3c0:	18 82       	st	Y, r1
 3c2:	19 82       	std	Y+1, r1	; 0x01
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:198
  rhs.capacity = 0;
 3c4:	1a 82       	std	Y+2, r1	; 0x02
 3c6:	1b 82       	std	Y+3, r1	; 0x03
 3c8:	e6 cf       	rjmp	.-52     	; 0x396 <String::move(String&)+0x3a>

000003ca <pinMode>:
check_valid_digital_pin():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:32
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
 3ca:	90 e0       	ldi	r25, 0x00	; 0
pinMode():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:161
  return port << 1;
}
void pinMode(uint8_t pin, uint8_t mode) {
  check_valid_digital_pin(pin);         /* generate compile error if a constant that is not a valid pin is used as the pin */
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
 3cc:	fc 01       	movw	r30, r24
 3ce:	ee 59       	subi	r30, 0x9E	; 158
 3d0:	f1 47       	sbci	r31, 0x71	; 113
 3d2:	20 81       	ld	r18, Z
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:162
  if ((bit_mask == NOT_A_PIN) || (mode > 3)) {
 3d4:	2f 3f       	cpi	r18, 0xFF	; 255
 3d6:	a9 f0       	breq	.+42     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:165
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = ((volatile uint8_t *) (uint16_t)(0x0400 | portToPortBaseOffset(digitalPinToPort(pin))));
 3d8:	fc 01       	movw	r30, r24
 3da:	e0 5b       	subi	r30, 0xB0	; 176
 3dc:	f1 47       	sbci	r31, 0x71	; 113
portToPortBaseOffset():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:155
  SREG=oldSREG; // re-enable interrupts
}

static inline uint8_t portToPortBaseOffset(uint8_t port);
static inline uint8_t portToPortBaseOffset(uint8_t port) {
  _SWAP(port);
 3de:	e0 81       	ld	r30, Z
 3e0:	e2 95       	swap	r30
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:156
  return port << 1;
 3e2:	ee 0f       	add	r30, r30
pinMode():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:165
  check_valid_pin_mode(mode);           /* generate compile error if a constant that is not a valid pin mode is used as the mode */
  uint8_t bit_mask = digitalPinToBitMask(pin);
  if ((bit_mask == NOT_A_PIN) || (mode > 3)) {
    return;                             /* ignore invalid pins passed at runtime */
  }
  volatile uint8_t * port_base = ((volatile uint8_t *) (uint16_t)(0x0400 | portToPortBaseOffset(digitalPinToPort(pin))));
 3e4:	f0 e0       	ldi	r31, 0x00	; 0
 3e6:	f4 60       	ori	r31, 0x04	; 4
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:166
  if (mode & 0x01) {
 3e8:	66 23       	and	r22, r22
 3ea:	61 f0       	breq	.+24     	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:168
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
 3ec:	21 83       	std	Z+1, r18	; 0x01
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:179
    } else if (mode == 0) {
      *(port_base + 6) = bit_mask;
    }
    */
  }
  port_base +=(uint8_t) digitalPinToBitPosition(pin) | (uint8_t) 0x10;
 3ee:	82 5c       	subi	r24, 0xC2	; 194
 3f0:	91 47       	sbci	r25, 0x71	; 113
 3f2:	dc 01       	movw	r26, r24
 3f4:	8c 91       	ld	r24, X
 3f6:	80 61       	ori	r24, 0x10	; 16
 3f8:	e8 0f       	add	r30, r24
 3fa:	f1 1d       	adc	r31, r1
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:180
  bit_mask = *port_base;
 3fc:	80 81       	ld	r24, Z
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:184
  if (mode & 2) {
    bit_mask |= 0x08;
  } else {
    bit_mask &= 0xF7;
 3fe:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:186
  }
  *port_base = bit_mask;
 400:	80 83       	st	Z, r24
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:187
}
 402:	08 95       	ret
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:170
  volatile uint8_t * port_base = ((volatile uint8_t *) (uint16_t)(0x0400 | portToPortBaseOffset(digitalPinToPort(pin))));
  if (mode & 0x01) {
    // OUTPUT mode, so write DIRSET with the mask.
    *(port_base + 1) = bit_mask;
  } else {
    *(port_base + 2) = bit_mask;
 404:	22 83       	std	Z+2, r18	; 0x02
 406:	f3 cf       	rjmp	.-26     	; 0x3ee <pinMode+0x24>

00000408 <_do_dre()>:
_Z7_do_drev():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:328
          "out        0x3f,     r18"      "\n\t"  // restore SREG
          "pop         r18"               "\n\t"  // pop old r18
          "pop         r31"               "\n\t"  // pop the Z that the isr pushed.
          "pop         r30"               "\n\t"
          "reti"                          "\n"   // and RETI!
          ::);
 408:	2f 93       	push	r18
 40a:	2f b7       	in	r18, 0x3f	; 63
 40c:	2f 93       	push	r18
 40e:	8f 93       	push	r24
 410:	9f 93       	push	r25
 412:	af 93       	push	r26
 414:	bf 93       	push	r27
 416:	68 94       	set

00000418 <_poll_dre>:
 418:	cf 93       	push	r28
 41a:	df 93       	push	r29
 41c:	20 e0       	ldi	r18, 0x00	; 0
 41e:	c0 85       	ldd	r28, Z+8	; 0x08
 420:	d8 e0       	ldi	r29, 0x08	; 8
 422:	90 89       	ldd	r25, Z+16	; 0x10
 424:	df 01       	movw	r26, r30
 426:	a9 0f       	add	r26, r25
 428:	b2 1f       	adc	r27, r18
 42a:	af 5a       	subi	r26, 0xAF	; 175
 42c:	bf 4f       	sbci	r27, 0xFF	; 255
 42e:	8c 91       	ld	r24, X
 430:	20 e4       	ldi	r18, 0x40	; 64
 432:	2c 83       	std	Y+4, r18	; 0x04
 434:	8a 83       	std	Y+2, r24	; 0x02
 436:	9f 5f       	subi	r25, 0xFF	; 255
 438:	9f 73       	andi	r25, 0x3F	; 63
 43a:	8d 81       	ldd	r24, Y+5	; 0x05
 43c:	27 85       	ldd	r18, Z+15	; 0x0f
 43e:	29 13       	cpse	r18, r25
 440:	02 c0       	rjmp	.+4      	; 0x446 <_done_dre_irq>
 442:	8f 7d       	andi	r24, 0xDF	; 223
 444:	8d 83       	std	Y+5, r24	; 0x05

00000446 <_done_dre_irq>:
 446:	90 8b       	std	Z+16, r25	; 0x10
 448:	df 91       	pop	r29
 44a:	cf 91       	pop	r28
 44c:	0e f0       	brts	.+2      	; 0x450 <_done_dre_irq+0xa>
 44e:	a5 ce       	rjmp	.-694    	; 0x19a <_poll_dre_done>
 450:	bf 91       	pop	r27
 452:	af 91       	pop	r26
 454:	9f 91       	pop	r25
 456:	8f 91       	pop	r24
 458:	2f 91       	pop	r18
 45a:	2f bf       	out	0x3f, r18	; 63
 45c:	2f 91       	pop	r18
 45e:	ff 91       	pop	r31
 460:	ef 91       	pop	r30
 462:	18 95       	reti

00000464 <_do_rxc()>:
_Z7_do_rxcv():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:193
            "pop        r30"              "\n\t" // pointer to serial instance
            "reti"                        "\n\t" // return
          "_buff_full_rxc:"               "\n\t" // potential improvement: move _buff_full_rxc to after the reti, and then rjmp back, saving 2 clocks for the common case
            "ori        r19,      0x40"   "\n\t" // record that there was a ring buffer overflow. 1 clk
            "rjmp _end_rxc"               "\n\t" // and now jump back to end. That way we don't need to jump over this in the middle of the common case.
            ::); // total: 77 or 79 clocks, just barely squeaks by for cyclic RX of up to RX_BUFFER_SIZE characters.
 464:	2f 93       	push	r18
 466:	2f b7       	in	r18, 0x3f	; 63
 468:	2f 93       	push	r18
 46a:	3f 93       	push	r19
 46c:	8f 93       	push	r24
 46e:	9f 93       	push	r25
 470:	cf 93       	push	r28
 472:	df 93       	push	r29
 474:	c0 85       	ldd	r28, Z+8	; 0x08
 476:	d8 e0       	ldi	r29, 0x08	; 8
 478:	89 81       	ldd	r24, Y+1	; 0x01
 47a:	98 81       	ld	r25, Y
 47c:	86 74       	andi	r24, 0x46	; 70
 47e:	88 0f       	add	r24, r24
 480:	34 85       	ldd	r19, Z+12	; 0x0c
 482:	38 2b       	or	r19, r24
 484:	82 fd       	sbrc	r24, 2
 486:	0d c0       	rjmp	.+26     	; 0x4a2 <_end_rxc>
 488:	c5 85       	ldd	r28, Z+13	; 0x0d
 48a:	81 e0       	ldi	r24, 0x01	; 1
 48c:	8c 0f       	add	r24, r28
 48e:	8f 73       	andi	r24, 0x3F	; 63
 490:	26 85       	ldd	r18, Z+14	; 0x0e
 492:	28 17       	cp	r18, r24
 494:	91 f0       	breq	.+36     	; 0x4ba <_buff_full_rxc>
 496:	ce 0f       	add	r28, r30
 498:	df 2f       	mov	r29, r31
 49a:	20 e0       	ldi	r18, 0x00	; 0
 49c:	d2 1f       	adc	r29, r18
 49e:	99 8b       	std	Y+17, r25	; 0x11
 4a0:	85 87       	std	Z+13, r24	; 0x0d

000004a2 <_end_rxc>:
 4a2:	34 87       	std	Z+12, r19	; 0x0c
 4a4:	df 91       	pop	r29
 4a6:	cf 91       	pop	r28
 4a8:	9f 91       	pop	r25
 4aa:	8f 91       	pop	r24
 4ac:	3f 91       	pop	r19
 4ae:	2f 91       	pop	r18
 4b0:	2f bf       	out	0x3f, r18	; 63
 4b2:	2f 91       	pop	r18
 4b4:	ff 91       	pop	r31
 4b6:	ef 91       	pop	r30
 4b8:	18 95       	reti

000004ba <_buff_full_rxc>:
 4ba:	30 64       	ori	r19, 0x40	; 64
 4bc:	f2 cf       	rjmp	.-28     	; 0x4a2 <_end_rxc>

000004be <_do_txc()>:
_Z7_do_txcv():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART.cpp:108
            "out     0x3f,      r24"  "\n\t"  // restore it
            "pop      r24"            "\n\t"  // pop r24 to get it's old value back
            "pop      r31"            "\n\t"  // and r31
            "pop      r30"            "\n\t"  // Pop the register the ISR did
            "reti"                    "\n"    // return from the interrupt.
            ::);
 4be:	ff 93       	push	r31
 4c0:	8f 93       	push	r24
 4c2:	8f b7       	in	r24, 0x3f	; 63
 4c4:	8f 93       	push	r24
 4c6:	f8 e0       	ldi	r31, 0x08	; 8

000004c8 <_txc_flush_rx>:
 4c8:	80 81       	ld	r24, Z
 4ca:	84 81       	ldd	r24, Z+4	; 0x04
 4cc:	87 ff       	sbrs	r24, 7
 4ce:	fc cf       	rjmp	.-8      	; 0x4c8 <_txc_flush_rx>
 4d0:	85 81       	ldd	r24, Z+5	; 0x05
 4d2:	8f 7b       	andi	r24, 0xBF	; 191
 4d4:	80 68       	ori	r24, 0x80	; 128
 4d6:	85 83       	std	Z+5, r24	; 0x05
 4d8:	8f 91       	pop	r24
 4da:	8f bf       	out	0x3f, r24	; 63
 4dc:	8f 91       	pop	r24
 4de:	ff 91       	pop	r31
 4e0:	ef 91       	pop	r30
 4e2:	18 95       	reti

000004e4 <__vector_15>:
__vector_15():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:170
      ISR(TCB4_INT_vect, ISR_NAKED)
    #else
      #error "No millis timer selected, but not disabled - cannot determine millis vector"
    #endif
  #endif // end of ISR statement, now for the ISR body
  {
 4e4:	1f 92       	push	r1
 4e6:	0f 92       	push	r0
 4e8:	0f b6       	in	r0, 0x3f	; 63
 4ea:	0f 92       	push	r0
 4ec:	11 24       	eor	r1, r1
 4ee:	2f 93       	push	r18
 4f0:	3f 93       	push	r19
 4f2:	4f 93       	push	r20
 4f4:	5f 93       	push	r21
 4f6:	6f 93       	push	r22
 4f8:	8f 93       	push	r24
 4fa:	9f 93       	push	r25
 4fc:	af 93       	push	r26
 4fe:	bf 93       	push	r27
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:229
        // Overflow count isn't used for TCB's
        if (RTC.INTFLAGS & RTC_OVF_bm) {
          timer_overflow_count++;
        }
      #else // TCA0 or TCD0
        uint32_t m = timer_millis;
 500:	80 91 18 38 	lds	r24, 0x3818	; 0x803818 <timer_millis>
 504:	90 91 19 38 	lds	r25, 0x3819	; 0x803819 <timer_millis+0x1>
 508:	a0 91 1a 38 	lds	r26, 0x381A	; 0x80381a <timer_millis+0x2>
 50c:	b0 91 1b 38 	lds	r27, 0x381B	; 0x80381b <timer_millis+0x3>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:230
        uint16_t f = timer_fract;
 510:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <timer_fract>
 514:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <timer_fract+0x1>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:232
        m += MILLIS_INC;
        f += FRACT_INC;
 518:	9a 01       	movw	r18, r20
 51a:	2c 5e       	subi	r18, 0xEC	; 236
 51c:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:233
        if (f >= FRACT_MAX) {
 51e:	28 3e       	cpi	r18, 0xE8	; 232
 520:	63 e0       	ldi	r22, 0x03	; 3
 522:	36 07       	cpc	r19, r22
 524:	98 f5       	brcc	.+102    	; 0x58c <__vector_15+0xa8>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:231
          timer_overflow_count++;
        }
      #else // TCA0 or TCD0
        uint32_t m = timer_millis;
        uint16_t f = timer_fract;
        m += MILLIS_INC;
 526:	01 96       	adiw	r24, 0x01	; 1
 528:	a1 1d       	adc	r26, r1
 52a:	b1 1d       	adc	r27, r1
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:238
        if (f >= FRACT_MAX) {

          f -= FRACT_MAX;
          m += 1;
        }
        timer_fract = f;
 52c:	20 93 16 38 	sts	0x3816, r18	; 0x803816 <timer_fract>
 530:	30 93 17 38 	sts	0x3817, r19	; 0x803817 <timer_fract+0x1>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:239
        timer_millis = m;
 534:	80 93 18 38 	sts	0x3818, r24	; 0x803818 <timer_millis>
 538:	90 93 19 38 	sts	0x3819, r25	; 0x803819 <timer_millis+0x1>
 53c:	a0 93 1a 38 	sts	0x381A, r26	; 0x80381a <timer_millis+0x2>
 540:	b0 93 1b 38 	sts	0x381B, r27	; 0x80381b <timer_millis+0x3>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:240
        timer_overflow_count++;
 544:	80 91 12 38 	lds	r24, 0x3812	; 0x803812 <timer_overflow_count>
 548:	90 91 13 38 	lds	r25, 0x3813	; 0x803813 <timer_overflow_count+0x1>
 54c:	a0 91 14 38 	lds	r26, 0x3814	; 0x803814 <timer_overflow_count+0x2>
 550:	b0 91 15 38 	lds	r27, 0x3815	; 0x803815 <timer_overflow_count+0x3>
 554:	01 96       	adiw	r24, 0x01	; 1
 556:	a1 1d       	adc	r26, r1
 558:	b1 1d       	adc	r27, r1
 55a:	80 93 12 38 	sts	0x3812, r24	; 0x803812 <timer_overflow_count>
 55e:	90 93 13 38 	sts	0x3813, r25	; 0x803813 <timer_overflow_count+0x1>
 562:	a0 93 14 38 	sts	0x3814, r26	; 0x803814 <timer_overflow_count+0x2>
 566:	b0 93 15 38 	sts	0x3815, r27	; 0x803815 <timer_overflow_count+0x3>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:246
      #endif
      /* Clear flag */
      #if defined(MILLIS_USE_TIMERA0)
        TCA0.SPLIT.INTFLAGS = TCA_SPLIT_HUNF_bm;
      #elif defined(MILLIS_USE_TIMERD0)
        TCD0.INTFLAGS = TCD_OVF_bm;
 56a:	81 e0       	ldi	r24, 0x01	; 1
 56c:	80 93 8d 0a 	sts	0x0A8D, r24	; 0x800a8d <vtable for HardwareSerial+0x7f7c19>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:251
      #elif defined(MILLIS_USE_TIMERRTC)
        RTC.INTFLAGS = RTC_OVF_bm | RTC_CMP_bm;
      #endif
    #endif
  }
 570:	bf 91       	pop	r27
 572:	af 91       	pop	r26
 574:	9f 91       	pop	r25
 576:	8f 91       	pop	r24
 578:	6f 91       	pop	r22
 57a:	5f 91       	pop	r21
 57c:	4f 91       	pop	r20
 57e:	3f 91       	pop	r19
 580:	2f 91       	pop	r18
 582:	0f 90       	pop	r0
 584:	0f be       	out	0x3f, r0	; 63
 586:	0f 90       	pop	r0
 588:	1f 90       	pop	r1
 58a:	18 95       	reti
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:235
        uint16_t f = timer_fract;
        m += MILLIS_INC;
        f += FRACT_INC;
        if (f >= FRACT_MAX) {

          f -= FRACT_MAX;
 58c:	9a 01       	movw	r18, r20
 58e:	24 5d       	subi	r18, 0xD4	; 212
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:236
          m += 1;
 590:	33 40       	sbci	r19, 0x03	; 3
 592:	02 96       	adiw	r24, 0x02	; 2
 594:	a1 1d       	adc	r26, r1
 596:	b1 1d       	adc	r27, r1
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART0.cpp:100
  #else
    ISR(USART0_DRE_vect, ISR_NAKED) {
      __asm__ __volatile__(
                "push  r30"    "\n\t"
                "push  r31"    "\n\t"
                :::);
 598:	c9 cf       	rjmp	.-110    	; 0x52c <__vector_15+0x48>

0000059a <__vector_28>:
__vector_28():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART0.cpp:107
#if PROGMEM_SIZE > 8192
                "jmp _do_dre"  "\n\t"
#else
                "rjmp _do_dre" "\n\t"
#endif
                ::"z"(&Serial0));
 59a:	ef 93       	push	r30
 59c:	ff 93       	push	r31
 59e:	ec e1       	ldi	r30, 0x1C	; 28
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART0.cpp:78
  #else
      ISR(USART0_RXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t" //we start out 5-6 clocks behind the ball, then do 2 push + 2 ldi + 2-3 for jump = 11 or 13 clocks to _do_rxc (and dre is the same)
              "push      r31"     "\n\t"
              :::);
 5a0:	f8 e3       	ldi	r31, 0x38	; 56
 5a2:	32 cf       	rjmp	.-412    	; 0x408 <_do_dre()>

000005a4 <__vector_27>:
__vector_27():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART0.cpp:85
#if PROGMEM_SIZE > 8192
              "jmp   _do_rxc"     "\n\t"
#else
              "rjmp   _do_rxc"    "\n\t"
#endif
              ::"z"(&Serial0));
 5a4:	ef 93       	push	r30
 5a6:	ff 93       	push	r31
 5a8:	ec e1       	ldi	r30, 0x1C	; 28
 5aa:	f8 e3       	ldi	r31, 0x38	; 56
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/UART0.cpp:51
            "jmp _do_txc"         "\n\t"
#else
            "rjmp _do_txc"        "\n\t"
#endif // _do_txc pushes the other necessary registers and loads 0x08 into the high byte.
       // The reason this is possible here and not elsewhere is because TXC only needs the USART, while the others need the HardwareSerial instance.
            :::);
 5ac:	5b cf       	rjmp	.-330    	; 0x464 <_do_rxc()>

000005ae <__vector_29>:
__vector_29():
 5ae:	ef 93       	push	r30
 5b0:	e0 e2       	ldi	r30, 0x20	; 32
 5b2:	85 cf       	rjmp	.-246    	; 0x4be <_do_txc()>

000005b4 <global constructors keyed to 65535_0_Mikro_Sensor.ino.cpp.o.2881>:
_GLOBAL__I_65535_0_Mikro_Sensor.ino.cpp.o.2881():
 5b4:	cf 93       	push	r28
 5b6:	df 93       	push	r29
 5b8:	10 92 1e 38 	sts	0x381E, r1	; 0x80381e <Serial0+0x2>
 5bc:	10 92 1f 38 	sts	0x381F, r1	; 0x80381f <Serial0+0x3>
 5c0:	88 ee       	ldi	r24, 0xE8	; 232
 5c2:	93 e0       	ldi	r25, 0x03	; 3
 5c4:	a0 e0       	ldi	r26, 0x00	; 0
 5c6:	b0 e0       	ldi	r27, 0x00	; 0
 5c8:	80 93 20 38 	sts	0x3820, r24	; 0x803820 <Serial0+0x4>
 5cc:	90 93 21 38 	sts	0x3821, r25	; 0x803821 <Serial0+0x5>
 5d0:	a0 93 22 38 	sts	0x3822, r26	; 0x803822 <Serial0+0x6>
 5d4:	b0 93 23 38 	sts	0x3823, r27	; 0x803823 <Serial0+0x7>
 5d8:	88 e7       	ldi	r24, 0x78	; 120
 5da:	9e e8       	ldi	r25, 0x8E	; 142
 5dc:	80 93 1c 38 	sts	0x381C, r24	; 0x80381c <Serial0>
 5e0:	90 93 1d 38 	sts	0x381D, r25	; 0x80381d <Serial0+0x1>
 5e4:	80 e0       	ldi	r24, 0x00	; 0
 5e6:	98 e0       	ldi	r25, 0x08	; 8
 5e8:	80 93 24 38 	sts	0x3824, r24	; 0x803824 <Serial0+0x8>
 5ec:	90 93 25 38 	sts	0x3825, r25	; 0x803825 <Serial0+0x9>
 5f0:	10 92 26 38 	sts	0x3826, r1	; 0x803826 <Serial0+0xa>
 5f4:	10 92 27 38 	sts	0x3827, r1	; 0x803827 <Serial0+0xb>
 5f8:	cd ea       	ldi	r28, 0xAD	; 173
 5fa:	d8 e3       	ldi	r29, 0x38	; 56
 5fc:	18 82       	st	Y, r1
 5fe:	19 82       	std	Y+1, r1	; 0x01
 600:	1a 82       	std	Y+2, r1	; 0x02
 602:	1b 82       	std	Y+3, r1	; 0x03
 604:	1c 82       	std	Y+4, r1	; 0x04
 606:	1d 82       	std	Y+5, r1	; 0x05
 608:	61 e0       	ldi	r22, 0x01	; 1
 60a:	70 e0       	ldi	r23, 0x00	; 0
 60c:	90 e0       	ldi	r25, 0x00	; 0
 60e:	80 e0       	ldi	r24, 0x00	; 0
 610:	44 d3       	rcall	.+1672   	; 0xc9a <realloc>
 612:	00 97       	sbiw	r24, 0x00	; 0
 614:	91 f0       	breq	.+36     	; 0x63a <global constructors keyed to 65535_0_Mikro_Sensor.ino.cpp.o.2881+0x86>
 616:	88 83       	st	Y, r24
 618:	99 83       	std	Y+1, r25	; 0x01
 61a:	1a 82       	std	Y+2, r1	; 0x02
 61c:	1b 82       	std	Y+3, r1	; 0x03
 61e:	2c 81       	ldd	r18, Y+4	; 0x04
 620:	3d 81       	ldd	r19, Y+5	; 0x05
 622:	23 2b       	or	r18, r19
 624:	11 f4       	brne	.+4      	; 0x62a <global constructors keyed to 65535_0_Mikro_Sensor.ino.cpp.o.2881+0x76>
 626:	fc 01       	movw	r30, r24
 628:	10 82       	st	Z, r1
 62a:	1c 82       	std	Y+4, r1	; 0x04
 62c:	1d 82       	std	Y+5, r1	; 0x05
 62e:	66 e8       	ldi	r22, 0x86	; 134
 630:	7e e8       	ldi	r23, 0x8E	; 142
 632:	88 81       	ld	r24, Y
 634:	99 81       	ldd	r25, Y+1	; 0x01
 636:	f0 d3       	rcall	.+2016   	; 0xe18 <strcpy>
 638:	0b c0       	rjmp	.+22     	; 0x650 <global constructors keyed to 65535_0_Mikro_Sensor.ino.cpp.o.2881+0x9c>
 63a:	88 81       	ld	r24, Y
 63c:	99 81       	ldd	r25, Y+1	; 0x01
 63e:	00 97       	sbiw	r24, 0x00	; 0
 640:	09 f0       	breq	.+2      	; 0x644 <global constructors keyed to 65535_0_Mikro_Sensor.ino.cpp.o.2881+0x90>
 642:	a2 d2       	rcall	.+1348   	; 0xb88 <free>
 644:	18 82       	st	Y, r1
 646:	19 82       	std	Y+1, r1	; 0x01
 648:	1c 82       	std	Y+4, r1	; 0x04
 64a:	1d 82       	std	Y+5, r1	; 0x05
 64c:	1a 82       	std	Y+2, r1	; 0x02
 64e:	1b 82       	std	Y+3, r1	; 0x03
 650:	26 96       	adiw	r28, 0x06	; 6
 652:	f9 e3       	ldi	r31, 0x39	; 57
 654:	c5 32       	cpi	r28, 0x25	; 37
 656:	df 07       	cpc	r29, r31
 658:	89 f6       	brne	.-94     	; 0x5fc <global constructors keyed to 65535_0_Mikro_Sensor.ino.cpp.o.2881+0x48>
 65a:	df 91       	pop	r29
 65c:	cf 91       	pop	r28
 65e:	08 95       	ret

00000660 <main>:
main():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/main.cpp:49
 * called first in non-optiboot configurations (neither is needed on Optibooot configurations() *
 * an extra bit of initialization code in .init3 to fix the vectors and still happen if user    *
 * overrides main. In the past there was a USB-related function here, that is removed, as work  *
 * will be needed in any event at the core level if VUSB-based "stuff" arrives, but really I'm  *
 * just waiting for the DU-series now                                                           */
int main() {
 660:	cf 93       	push	r28
 662:	df 93       	push	r29
 664:	cd b7       	in	r28, 0x3d	; 61
 666:	de b7       	in	r29, 0x3e	; 62
 668:	26 97       	sbiw	r28, 0x06	; 6
 66a:	cd bf       	out	0x3d, r28	; 61
 66c:	de bf       	out	0x3e, r29	; 62
init_clock():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1387
      #if (F_CPU == 20000000)
        /* No division on clock */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
      #elif (F_CPU == 16000000)
        /* No division on clock */
        _PROTECTED_WRITE(CLKCTRL_MCLKCTRLB, 0x00);
 66e:	88 ed       	ldi	r24, 0xD8	; 216
 670:	90 e0       	ldi	r25, 0x00	; 0
 672:	84 bf       	out	0x34, r24	; 52
 674:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <vtable for HardwareSerial+0x7f71ed>
init_ADC0():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1518
   **************************************************************************/
    //                              30 MHz / 32 = 937 kHz,  32 MHz / 32 =  1 MHz.
    #if   F_CPU   > 24000000     // 24 MHz / 16 = 1.5 MHz,  25 MHz / 32 =  780 kHz
      ADC0.CTRLC  = ADC_PRESC_DIV32_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
    #elif F_CPU  >= 12000000    // 16 MHz / 16 = 1.0 MHz,  20 MHz / 16 = 1.25 MHz
      ADC0.CTRLC  = ADC_PRESC_DIV16_gc | ADC_REFSEL_VDDREF_gc | ADC_SAMPCAP_bm;
 678:	83 e5       	ldi	r24, 0x53	; 83
 67a:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <vtable for HardwareSerial+0x7f778e>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1531
    #if   (F_CPU == 6000000 || F_CPU == 12000000 || F_CPU == 24000000 || F_CPU ==25000000)
      ADC0.SAMPCTRL = (7); // 9 ADC clocks, 12 us
    #elif (F_CPU == 5000000 || F_CPU == 10000000 || F_CPU == 20000000)
      ADC0.SAMPCTRL = (13);   // 15 ADC clock,s 12 us
    #else
      ADC0.SAMPCTRL = (10); // 12 ADC clocks, 12 us
 67e:	8a e0       	ldi	r24, 0x0A	; 10
 680:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <vtable for HardwareSerial+0x7f7791>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1533
    #endif
    ADC0.CTRLD    = ADC_INITDLY_DLY16_gc;
 684:	80 e2       	ldi	r24, 0x20	; 32
 686:	80 93 03 06 	sts	0x0603, r24	; 0x800603 <vtable for HardwareSerial+0x7f778f>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1534
    ADC0.CTRLA    = ADC_ENABLE_bm;
 68a:	81 e0       	ldi	r24, 0x01	; 1
 68c:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <vtable for HardwareSerial+0x7f778c>
init_TCA0():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1626
  #ifdef __AVR_ATtinyxy2__
    PORTMUX.CTRLC = 1; // move WO0 output to PA7 so PA3 can be used with WO3
  #endif

  /* Enable Split Mode */
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
 690:	80 93 03 0a 	sts	0x0A03, r24	; 0x800a03 <vtable for HardwareSerial+0x7f7b8f>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1631

  // Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
 694:	9e ef       	ldi	r25, 0xFE	; 254
 696:	90 93 26 0a 	sts	0x0A26, r25	; 0x800a26 <vtable for HardwareSerial+0x7f7bb2>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1632
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
 69a:	90 93 27 0a 	sts	0x0A27, r25	; 0x800a27 <vtable for HardwareSerial+0x7f7bb3>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1659
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) // use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA0) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA0 to different divider"
    #endif
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
 69e:	9b e0       	ldi	r25, 0x0B	; 11
 6a0:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <vtable for HardwareSerial+0x7f7b8c>
init_millis():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1281
    #if defined(MILLIS_USE_TIMERA0)
      TCA0.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERA1)
      TCA1.SPLIT.INTCTRL |= TCA_SPLIT_HUNF_bm;
    #elif defined(MILLIS_USE_TIMERD0)
      TCD0.CMPBCLR        = TIME_TRACKING_TIMER_PERIOD; // essentially, this is TOP
 6a4:	2d ef       	ldi	r18, 0xFD	; 253
 6a6:	31 e0       	ldi	r19, 0x01	; 1
 6a8:	20 93 ae 0a 	sts	0x0AAE, r18	; 0x800aae <vtable for HardwareSerial+0x7f7c3a>
 6ac:	30 93 af 0a 	sts	0x0AAF, r19	; 0x800aaf <vtable for HardwareSerial+0x7f7c3b>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1282
      TCD0.CTRLB          = 0x00; // oneramp mode
 6b0:	10 92 81 0a 	sts	0x0A81, r1	; 0x800a81 <vtable for HardwareSerial+0x7f7c0d>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1283
      TCD0.CTRLC          = 0x80;
 6b4:	90 e8       	ldi	r25, 0x80	; 128
 6b6:	90 93 82 0a 	sts	0x0A82, r25	; 0x800a82 <vtable for HardwareSerial+0x7f7c0e>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1284
      TCD0.INTCTRL        = 0x01; // enable interrupt
 6ba:	80 93 8c 0a 	sts	0x0A8C, r24	; 0x800a8c <vtable for HardwareSerial+0x7f7c18>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring.c:1285
      TCD0.CTRLA          = TIMERD0_PRESCALER | 0x01; // set clock source and enable!
 6be:	81 e1       	ldi	r24, 0x11	; 17
 6c0:	80 93 80 0a 	sts	0x0A80, r24	; 0x800a80 <vtable for HardwareSerial+0x7f7c0c>
main():
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:77
   }               
}

void setup(){
//  Serial.begin(9600);
    pinMode(dataOut, OUTPUT);
 6c4:	78 94       	sei
setup():
 6c6:	61 e0       	ldi	r22, 0x01	; 1
 6c8:	85 e0       	ldi	r24, 0x05	; 5
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:78
    pinMode(clkIn, INPUT);
 6ca:	7f de       	rcall	.-770    	; 0x3ca <pinMode>
 6cc:	60 e0       	ldi	r22, 0x00	; 0
 6ce:	84 e0       	ldi	r24, 0x04	; 4
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:79
    pinMode(sensor, INPUT);
 6d0:	7c de       	rcall	.-776    	; 0x3ca <pinMode>
 6d2:	60 e0       	ldi	r22, 0x00	; 0
 6d4:	82 e0       	ldi	r24, 0x02	; 2
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:80
    pinMode(sensor2, INPUT);
 6d6:	79 de       	rcall	.-782    	; 0x3ca <pinMode>
 6d8:	60 e0       	ldi	r22, 0x00	; 0
 6da:	83 e0       	ldi	r24, 0x03	; 3
 6dc:	76 de       	rcall	.-788    	; 0x3ca <pinMode>
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:81
    b = 0;
 6de:	10 92 0e 38 	sts	0x380E, r1	; 0x80380e <b>
 6e2:	10 92 0f 38 	sts	0x380F, r1	; 0x80380f <b+0x1>
toInt():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:800
/*********************************************/
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const {
  if (buffer) {
 6e6:	36 e0       	ldi	r19, 0x06	; 6
 6e8:	33 2e       	mov	r3, r19
digitalWrite():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:322
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
 6ea:	40 e1       	ldi	r20, 0x10	; 16
 6ec:	24 2e       	mov	r2, r20
convert_tobinary():
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:28
String dataArray3[20];


void convert_tobinary(int input, int input2){
  dat = 0;
  for(a=512; a>=1; a=a/2){
 6ee:	41 2c       	mov	r4, r1
 6f0:	52 e0       	ldi	r21, 0x02	; 2
 6f2:	55 2e       	mov	r5, r21
send_data():
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:52
  }
}


void send_data(){
  last = current;
 6f4:	80 91 11 38 	lds	r24, 0x3811	; 0x803811 <current>
 6f8:	80 93 10 38 	sts	0x3810, r24	; 0x803810 <last>
digitalRead():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:415

  /* Get port and check valid port */
  PORT_t *port = digitalPinToPortStruct(pin);

  /* Read pin value from PORTx.IN register */
  if (port->IN & bit_mask) {
 6fc:	20 91 28 04 	lds	r18, 0x0428	; 0x800428 <vtable for HardwareSerial+0x7f75b4>
 700:	91 e0       	ldi	r25, 0x01	; 1
 702:	32 2f       	mov	r19, r18
 704:	30 72       	andi	r19, 0x20	; 32
 706:	25 ff       	sbrs	r18, 5
 708:	90 e0       	ldi	r25, 0x00	; 0
send_data():
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:53
  current = digitalRead(clkIn);
 70a:	90 93 11 38 	sts	0x3811, r25	; 0x803811 <current>
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:54
  if(last == 0 && current == 1){
 70e:	81 11       	cpse	r24, r1
 710:	41 c0       	rjmp	.+130    	; 0x794 <main+0x134>
 712:	33 23       	and	r19, r19
 714:	09 f4       	brne	.+2      	; 0x718 <main+0xb8>
 716:	3e c0       	rjmp	.+124    	; 0x794 <main+0x134>
toInt():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:800
 718:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <b>
 71c:	90 91 0f 38 	lds	r25, 0x380F	; 0x80380f <b+0x1>
 720:	38 9e       	mul	r3, r24
 722:	f0 01       	movw	r30, r0
 724:	39 9e       	mul	r3, r25
 726:	f0 0d       	add	r31, r0
 728:	11 24       	eor	r1, r1
 72a:	e3 55       	subi	r30, 0x53	; 83
 72c:	f7 4c       	sbci	r31, 0xC7	; 199
 72e:	80 81       	ld	r24, Z
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:803
    return atol(buffer);
  }
  return 0;
 730:	91 81       	ldd	r25, Z+1	; 0x01
main():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:800
/*********************************************/
/*  Parsing / Conversion                     */
/*********************************************/

long String::toInt(void) const {
  if (buffer) {
 732:	60 e0       	ldi	r22, 0x00	; 0
toInt():
 734:	00 97       	sbiw	r24, 0x00	; 0
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:801
    return atol(buffer);
 736:	09 f0       	breq	.+2      	; 0x73a <main+0xda>
 738:	19 d1       	rcall	.+562    	; 0x96c <atol>
digitalWrite():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:301
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
 73a:	61 11       	cpse	r22, r1
 73c:	a4 c0       	rjmp	.+328    	; 0x886 <__DATA_REGION_LENGTH__+0x86>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:302
    port->OUTCLR = bit_mask;
 73e:	20 92 26 04 	sts	0x0426, r2	; 0x800426 <vtable for HardwareSerial+0x7f75b2>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:326
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
 742:	80 91 20 04 	lds	r24, 0x0420	; 0x800420 <vtable for HardwareSerial+0x7f75ac>
 746:	84 fd       	sbrc	r24, 4
 748:	0a c0       	rjmp	.+20     	; 0x75e <main+0xfe>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:339

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
 74a:	9f b7       	in	r25, 0x3f	; 63
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:340
    cli();
 74c:	f8 94       	cli
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:344

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 74e:	80 91 34 04 	lds	r24, 0x0434	; 0x800434 <vtable for HardwareSerial+0x7f75c0>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:342

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
 752:	61 11       	cpse	r22, r1
 754:	a5 c0       	rjmp	.+330    	; 0x8a0 <__DATA_REGION_LENGTH__+0xa0>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:344
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
 756:	87 7f       	andi	r24, 0xF7	; 247
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:347
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 758:	80 93 34 04 	sts	0x0434, r24	; 0x800434 <vtable for HardwareSerial+0x7f75c0>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:351
    }

    /* Restore system status */
    SREG = status;
 75c:	9f bf       	out	0x3f, r25	; 63
send_data():
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:57
     lowvar = 0;
     digitalWrite(dataOut, dataArray3[b].toInt());
     Serial.print(dataArray3[b]);
 75e:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <b>
 762:	90 91 0f 38 	lds	r25, 0x380F	; 0x80380f <b+0x1>
 766:	38 9e       	mul	r3, r24
 768:	f0 01       	movw	r30, r0
 76a:	39 9e       	mul	r3, r25
 76c:	f0 0d       	add	r31, r0
 76e:	11 24       	eor	r1, r1
 770:	e3 55       	subi	r30, 0x53	; 83
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/Print.h:60
      }
      return write((const uint8_t *)str, strlen(str));
    }
    virtual size_t write(const uint8_t *buffer, size_t size);
    size_t write(const char *buffer, size_t size) {
      return write((const uint8_t *)buffer, size);
 772:	f7 4c       	sbci	r31, 0xC7	; 199
write():
 774:	44 81       	ldd	r20, Z+4	; 0x04
 776:	55 81       	ldd	r21, Z+5	; 0x05
 778:	60 81       	ld	r22, Z
 77a:	71 81       	ldd	r23, Z+1	; 0x01
 77c:	8c e1       	ldi	r24, 0x1C	; 28
 77e:	98 e3       	ldi	r25, 0x38	; 56
 780:	6e dd       	rcall	.-1316   	; 0x25e <Print::write(unsigned char const*, unsigned int)>
send_data():
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:58
     b++;
 782:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <b>
 786:	90 91 0f 38 	lds	r25, 0x380F	; 0x80380f <b+0x1>
 78a:	01 96       	adiw	r24, 0x01	; 1
 78c:	80 93 0e 38 	sts	0x380E, r24	; 0x80380e <b>
 790:	90 93 0f 38 	sts	0x380F, r25	; 0x80380f <b+0x1>
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:60
   }
  if(b > 20){
 794:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <b>
 798:	90 91 0f 38 	lds	r25, 0x380F	; 0x80380f <b+0x1>
 79c:	45 97       	sbiw	r24, 0x15	; 21
 79e:	0c f4       	brge	.+2      	; 0x7a2 <main+0x142>
 7a0:	a9 cf       	rjmp	.-174    	; 0x6f4 <main+0x94>
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:61
     b = 0;
 7a2:	10 92 0e 38 	sts	0x380E, r1	; 0x80380e <b>
 7a6:	10 92 0f 38 	sts	0x380F, r1	; 0x80380f <b+0x1>
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:63
     lowvar = 1;
     current = 0;
 7aa:	10 92 11 38 	sts	0x3811, r1	; 0x803811 <current>
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:64
     last = 0;
 7ae:	10 92 10 38 	sts	0x3810, r1	; 0x803810 <last>
analogRead():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_analog.c:698
      // don't waste flash on smallest parts.
      if ((pin & 0x7F) > 0x1F) { // highest valid mux value for any 0 or 1-series part.
        return ADC_ERROR_BAD_PIN_OR_CHANNEL;
      }
    #endif
    if (!ADC0.CTRLA & 0x01) return ADC_ERROR_DISABLED;
 7b2:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <vtable for HardwareSerial+0x7f778c>
main():
 7b6:	09 ef       	ldi	r16, 0xF9	; 249
 7b8:	12 e8       	ldi	r17, 0x82	; 130
analogRead():
 7ba:	88 23       	and	r24, r24
 7bc:	69 f0       	breq	.+26     	; 0x7d8 <main+0x178>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_analog.c:702
    pin &= 0x1F;
    /* Reference should be already set up */
    /* Select channel */
    ADC0.MUXPOS = (pin << ADC_MUXPOS_gp);
 7be:	30 92 06 06 	sts	0x0606, r3	; 0x800606 <vtable for HardwareSerial+0x7f7792>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_analog.c:709
    #if defined(STRICT_ERROR_CHECKING)
      if (ADC0.COMMAND) return ADC_ERROR_BUSY;
    #endif

    /* Start conversion */
    ADC0.COMMAND = ADC_STCONV_bm;
 7c2:	21 e0       	ldi	r18, 0x01	; 1
 7c4:	20 93 08 06 	sts	0x0608, r18	; 0x800608 <vtable for HardwareSerial+0x7f7794>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_analog.c:712

    /* Wait for result ready */
    while (!(ADC0.INTFLAGS & ADC_RESRDY_bm));
 7c8:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <vtable for HardwareSerial+0x7f7797>
 7cc:	80 ff       	sbrs	r24, 0
 7ce:	fc cf       	rjmp	.-8      	; 0x7c8 <main+0x168>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_analog.c:715

    /* Combine two bytes */
    return ADC0.RES;
 7d0:	00 91 10 06 	lds	r16, 0x0610	; 0x800610 <vtable for HardwareSerial+0x7f779c>
 7d4:	10 91 11 06 	lds	r17, 0x0611	; 0x800611 <vtable for HardwareSerial+0x7f779d>
send_data():
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:69
//     Serial.print(dataSensor2);
//     Serial.print("-");
//     Serial.print(dataSensor1);
//     Serial.println(",");
     dataSensor2 = analogRead(sensor);
 7d8:	00 93 0c 38 	sts	0x380C, r16	; 0x80380c <dataSensor2>
 7dc:	10 93 0d 38 	sts	0x380D, r17	; 0x80380d <dataSensor2+0x1>
analogRead():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_analog.c:698
      // don't waste flash on smallest parts.
      if ((pin & 0x7F) > 0x1F) { // highest valid mux value for any 0 or 1-series part.
        return ADC_ERROR_BAD_PIN_OR_CHANNEL;
      }
    #endif
    if (!ADC0.CTRLA & 0x01) return ADC_ERROR_DISABLED;
 7e0:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <vtable for HardwareSerial+0x7f778c>
main():
 7e4:	29 ef       	ldi	r18, 0xF9	; 249
 7e6:	c2 2e       	mov	r12, r18
 7e8:	22 e8       	ldi	r18, 0x82	; 130
 7ea:	d2 2e       	mov	r13, r18
analogRead():
 7ec:	88 23       	and	r24, r24
 7ee:	71 f0       	breq	.+28     	; 0x80c <__DATA_REGION_LENGTH__+0xc>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_analog.c:702
    pin &= 0x1F;
    /* Reference should be already set up */
    /* Select channel */
    ADC0.MUXPOS = (pin << ADC_MUXPOS_gp);
 7f0:	37 e0       	ldi	r19, 0x07	; 7
 7f2:	30 93 06 06 	sts	0x0606, r19	; 0x800606 <vtable for HardwareSerial+0x7f7792>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_analog.c:709
    #if defined(STRICT_ERROR_CHECKING)
      if (ADC0.COMMAND) return ADC_ERROR_BUSY;
    #endif

    /* Start conversion */
    ADC0.COMMAND = ADC_STCONV_bm;
 7f6:	81 e0       	ldi	r24, 0x01	; 1
 7f8:	80 93 08 06 	sts	0x0608, r24	; 0x800608 <vtable for HardwareSerial+0x7f7794>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_analog.c:712

    /* Wait for result ready */
    while (!(ADC0.INTFLAGS & ADC_RESRDY_bm));
 7fc:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <vtable for HardwareSerial+0x7f7797>
 800:	80 ff       	sbrs	r24, 0
 802:	fc cf       	rjmp	.-8      	; 0x7fc <main+0x19c>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_analog.c:715

    /* Combine two bytes */
    return ADC0.RES;
 804:	c0 90 10 06 	lds	r12, 0x0610	; 0x800610 <vtable for HardwareSerial+0x7f779c>
 808:	d0 90 11 06 	lds	r13, 0x0611	; 0x800611 <vtable for HardwareSerial+0x7f779d>
convert_tobinary():
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:27
int dataArray2[20] = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0};
String dataArray3[20];


void convert_tobinary(int input, int input2){
  dat = 0;
 80c:	10 92 0a 38 	sts	0x380A, r1	; 0x80380a <dat>
 810:	10 92 0b 38 	sts	0x380B, r1	; 0x80380b <dat+0x1>
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:28
  for(a=512; a>=1; a=a/2){
 814:	40 92 08 38 	sts	0x3808, r4	; 0x803808 <a>
 818:	50 92 09 38 	sts	0x3809, r5	; 0x803809 <a+0x1>
 81c:	e0 90 08 38 	lds	r14, 0x3808	; 0x803808 <a>
 820:	f0 90 09 38 	lds	r15, 0x3809	; 0x803809 <a+0x1>
 824:	1e 14       	cp	r1, r14
 826:	1f 04       	cpc	r1, r15
 828:	0c f0       	brlt	.+2      	; 0x82c <__DATA_REGION_LENGTH__+0x2c>
 82a:	4a c0       	rjmp	.+148    	; 0x8c0 <__DATA_REGION_LENGTH__+0xc0>
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:29
    if((input-a)>=0){
 82c:	48 01       	movw	r8, r16
 82e:	8e 18       	sub	r8, r14
 830:	9f 08       	sbc	r9, r15
 832:	60 90 0a 38 	lds	r6, 0x380A	; 0x80380a <dat>
 836:	70 90 0b 38 	lds	r7, 0x380B	; 0x80380b <dat+0x1>
 83a:	36 9c       	mul	r3, r6
 83c:	c0 01       	movw	r24, r0
 83e:	37 9c       	mul	r3, r7
 840:	90 0d       	add	r25, r0
 842:	11 24       	eor	r1, r1
 844:	9c 01       	movw	r18, r24
 846:	23 55       	subi	r18, 0x53	; 83
 848:	37 4c       	sbci	r19, 0xC7	; 199
 84a:	59 01       	movw	r10, r18
 84c:	97 fc       	sbrc	r9, 7
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.h:280

class StringSumHelper : public String {
  public:
    StringSumHelper(const String &s) : String(s) {}
    StringSumHelper(const char *p) : String(p) {}
    StringSumHelper(char c) : String(c) {}
 84e:	2a c0       	rjmp	.+84     	; 0x8a4 <__DATA_REGION_LENGTH__+0xa4>
_ZN15StringSumHelperC2Ec():
 850:	61 e3       	ldi	r22, 0x31	; 49
 852:	ce 01       	movw	r24, r28
 854:	01 96       	adiw	r24, 0x01	; 1
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:227
  return *this;
}

String &String::operator = (StringSumHelper &&rval) {
  if (this != &rval) {
    move(rval);
 856:	30 dd       	rcall	.-1440   	; 0x2b8 <String::String(char)>
operator=():
 858:	be 01       	movw	r22, r28
 85a:	6f 5f       	subi	r22, 0xFF	; 255
 85c:	7f 4f       	sbci	r23, 0xFF	; 255
 85e:	c5 01       	movw	r24, r10
 860:	7d dd       	rcall	.-1286   	; 0x35c <String::move(String&)>
__base_dtor ():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:114
  char buf[33];
  *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}

String::~String() {
  free(buffer);
 862:	89 81       	ldd	r24, Y+1	; 0x01
 864:	9a 81       	ldd	r25, Y+2	; 0x02
 866:	90 d1       	rcall	.+800    	; 0xb88 <free>
convert_tobinary():
 868:	3f ef       	ldi	r19, 0xFF	; 255
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:36
      input-=a; 
    }
    else{
      dataArray3[dat]='0';
    } 
    dat++;  
 86a:	63 1a       	sub	r6, r19
 86c:	73 0a       	sbc	r7, r19
 86e:	60 92 0a 38 	sts	0x380A, r6	; 0x80380a <dat>
 872:	70 92 0b 38 	sts	0x380B, r7	; 0x80380b <dat+0x1>
 876:	f5 94       	asr	r15
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:28
String dataArray3[20];


void convert_tobinary(int input, int input2){
  dat = 0;
  for(a=512; a>=1; a=a/2){
 878:	e7 94       	ror	r14
 87a:	e0 92 08 38 	sts	0x3808, r14	; 0x803808 <a>
 87e:	f0 92 09 38 	sts	0x3809, r15	; 0x803809 <a+0x1>
 882:	84 01       	movw	r16, r8
 884:	cb cf       	rjmp	.-106    	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
digitalWrite():
 886:	64 30       	cpi	r22, 0x04	; 4
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:303
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
  } else if (val == CHANGE) { /* If TOGGLE
 888:	41 f4       	brne	.+16     	; 0x89a <__DATA_REGION_LENGTH__+0x9a>
 88a:	80 91 24 04 	lds	r24, 0x0424	; 0x800424 <vtable for HardwareSerial+0x7f75b0>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:310
     * we need to know if it's been set high or low
     * otherwise the pullup state could get out of
     * sync with the output bit. Annoying! But we should
     * have to read it before writing OUTTGL, since that can
     * have a 1 clock delay. So read first + invert */
    val = !(port->OUT & bit_mask);
 88e:	20 92 27 04 	sts	0x0427, r2	; 0x800427 <vtable for HardwareSerial+0x7f75b3>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:311
    port->OUTTGL = bit_mask;
 892:	60 91 24 04 	lds	r22, 0x0424	; 0x800424 <vtable for HardwareSerial+0x7f75b0>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:316
    // Now, for the pullup setting part below
    // we need to know if it's been set high or low
    // otherwise the pullup state could get out of
    // sync with the output bit. Annoying!
    val = port->OUT & bit_mask;
 896:	60 71       	andi	r22, 0x10	; 16
 898:	54 cf       	rjmp	.-344    	; 0x742 <main+0xe2>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:322
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
 89a:	20 92 25 04 	sts	0x0425, r2	; 0x800425 <vtable for HardwareSerial+0x7f75b1>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore/wiring_digital.c:347
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
 89e:	51 cf       	rjmp	.-350    	; 0x742 <main+0xe2>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.h:280
 8a0:	88 60       	ori	r24, 0x08	; 8
 8a2:	5a cf       	rjmp	.-332    	; 0x758 <main+0xf8>
_ZN15StringSumHelperC2Ec():
 8a4:	60 e3       	ldi	r22, 0x30	; 48
 8a6:	ce 01       	movw	r24, r28
 8a8:	01 96       	adiw	r24, 0x01	; 1
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:227
  return *this;
}

String &String::operator = (StringSumHelper &&rval) {
  if (this != &rval) {
    move(rval);
 8aa:	06 dd       	rcall	.-1524   	; 0x2b8 <String::String(char)>
operator=():
 8ac:	be 01       	movw	r22, r28
 8ae:	6f 5f       	subi	r22, 0xFF	; 255
 8b0:	7f 4f       	sbci	r23, 0xFF	; 255
 8b2:	c5 01       	movw	r24, r10
 8b4:	53 dd       	rcall	.-1370   	; 0x35c <String::move(String&)>
__base_dtor ():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:114
  char buf[33];
  *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}

String::~String() {
  free(buffer);
 8b6:	89 81       	ldd	r24, Y+1	; 0x01
 8b8:	9a 81       	ldd	r25, Y+2	; 0x02
 8ba:	66 d1       	rcall	.+716    	; 0xb88 <free>
convert_tobinary():
 8bc:	48 01       	movw	r8, r16
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:34
    if((input-a)>=0){
      dataArray3[dat]= '1';
      input-=a; 
    }
    else{
      dataArray3[dat]='0';
 8be:	d4 cf       	rjmp	.-88     	; 0x868 <__DATA_REGION_LENGTH__+0x68>
 8c0:	40 92 06 38 	sts	0x3806, r4	; 0x803806 <__data_end>
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:38
    } 
    dat++;  
  }
    for(a2=512; a2>=1; a2=a2/2){
 8c4:	50 92 07 38 	sts	0x3807, r5	; 0x803807 <__data_end+0x1>
 8c8:	00 91 06 38 	lds	r16, 0x3806	; 0x803806 <__data_end>
 8cc:	10 91 07 38 	lds	r17, 0x3807	; 0x803807 <__data_end+0x1>
 8d0:	10 16       	cp	r1, r16
 8d2:	11 06       	cpc	r1, r17
 8d4:	0c f0       	brlt	.+2      	; 0x8d8 <__DATA_REGION_LENGTH__+0xd8>
 8d6:	0e cf       	rjmp	.-484    	; 0x6f4 <main+0x94>
 8d8:	56 01       	movw	r10, r12
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:39
    if((input2-a2)>=0){
 8da:	a0 1a       	sub	r10, r16
 8dc:	b1 0a       	sbc	r11, r17
 8de:	80 90 0a 38 	lds	r8, 0x380A	; 0x80380a <dat>
 8e2:	90 90 0b 38 	lds	r9, 0x380B	; 0x80380b <dat+0x1>
 8e6:	38 9c       	mul	r3, r8
 8e8:	c0 01       	movw	r24, r0
 8ea:	39 9c       	mul	r3, r9
 8ec:	90 0d       	add	r25, r0
 8ee:	11 24       	eor	r1, r1
 8f0:	9c 01       	movw	r18, r24
 8f2:	23 55       	subi	r18, 0x53	; 83
 8f4:	37 4c       	sbci	r19, 0xC7	; 199
 8f6:	79 01       	movw	r14, r18
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.h:280
 8f8:	b7 fc       	sbrc	r11, 7
 8fa:	1b c0       	rjmp	.+54     	; 0x932 <__DATA_REGION_LENGTH__+0x132>
_ZN15StringSumHelperC2Ec():
 8fc:	61 e3       	ldi	r22, 0x31	; 49
 8fe:	ce 01       	movw	r24, r28
 900:	01 96       	adiw	r24, 0x01	; 1
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:227
  return *this;
}

String &String::operator = (StringSumHelper &&rval) {
  if (this != &rval) {
    move(rval);
 902:	da dc       	rcall	.-1612   	; 0x2b8 <String::String(char)>
operator=():
 904:	be 01       	movw	r22, r28
 906:	6f 5f       	subi	r22, 0xFF	; 255
 908:	7f 4f       	sbci	r23, 0xFF	; 255
 90a:	c7 01       	movw	r24, r14
 90c:	27 dd       	rcall	.-1458   	; 0x35c <String::move(String&)>
__base_dtor ():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:114
  char buf[33];
  *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}

String::~String() {
  free(buffer);
 90e:	89 81       	ldd	r24, Y+1	; 0x01
 910:	9a 81       	ldd	r25, Y+2	; 0x02
 912:	3a d1       	rcall	.+628    	; 0xb88 <free>
convert_tobinary():
 914:	3f ef       	ldi	r19, 0xFF	; 255
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:46
      input2-=a2; 
    }
    else{
      dataArray3[dat]='0';
    } 
    dat++;  
 916:	83 1a       	sub	r8, r19
 918:	93 0a       	sbc	r9, r19
 91a:	80 92 0a 38 	sts	0x380A, r8	; 0x80380a <dat>
 91e:	90 92 0b 38 	sts	0x380B, r9	; 0x80380b <dat+0x1>
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:38
    else{
      dataArray3[dat]='0';
    } 
    dat++;  
  }
    for(a2=512; a2>=1; a2=a2/2){
 922:	15 95       	asr	r17
 924:	07 95       	ror	r16
 926:	00 93 06 38 	sts	0x3806, r16	; 0x803806 <__data_end>
 92a:	10 93 07 38 	sts	0x3807, r17	; 0x803807 <__data_end+0x1>
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.h:280
 92e:	65 01       	movw	r12, r10
 930:	cb cf       	rjmp	.-106    	; 0x8c8 <__DATA_REGION_LENGTH__+0xc8>
_ZN15StringSumHelperC2Ec():
 932:	60 e3       	ldi	r22, 0x30	; 48
 934:	ce 01       	movw	r24, r28
 936:	01 96       	adiw	r24, 0x01	; 1
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:227
  return *this;
}

String &String::operator = (StringSumHelper &&rval) {
  if (this != &rval) {
    move(rval);
 938:	bf dc       	rcall	.-1666   	; 0x2b8 <String::String(char)>
operator=():
 93a:	be 01       	movw	r22, r28
 93c:	6f 5f       	subi	r22, 0xFF	; 255
 93e:	7f 4f       	sbci	r23, 0xFF	; 255
 940:	c7 01       	movw	r24, r14
 942:	0c dd       	rcall	.-1512   	; 0x35c <String::move(String&)>
__base_dtor ():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:114
  char buf[33];
  *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}

String::~String() {
  free(buffer);
 944:	89 81       	ldd	r24, Y+1	; 0x01
 946:	9a 81       	ldd	r25, Y+2	; 0x02
 948:	1f d1       	rcall	.+574    	; 0xb88 <free>
convert_tobinary():
 94a:	56 01       	movw	r10, r12
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:44
    if((input2-a2)>=0){
      dataArray3[dat]= '1';
      input2-=a2; 
    }
    else{
      dataArray3[dat]='0';
 94c:	e3 cf       	rjmp	.-58     	; 0x914 <__DATA_REGION_LENGTH__+0x114>

0000094e <_GLOBAL__sub_D_a>:
_GLOBAL__sub_D_a():
 94e:	cf 93       	push	r28
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:86
    b = 0;
}

void loop(){
  send_data();
}
 950:	df 93       	push	r29
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:23
int dataSensor2;
uint8_t current = 0;
uint8_t last = 0;
int dataArray[20] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1};
int dataArray2[20] = {1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0};
String dataArray3[20];
 952:	c5 e2       	ldi	r28, 0x25	; 37
 954:	d9 e3       	ldi	r29, 0x39	; 57
__static_initialization_and_destruction_0():
 956:	26 97       	sbiw	r28, 0x06	; 6
__base_dtor ():
C:\Users\Xirka (Throwaway)\AppData\Local\Arduino15\packages\megaTinyCore\hardware\megaavr\2.6.1\cores\megatinycore\api/String.cpp:114
 958:	88 81       	ld	r24, Y
 95a:	99 81       	ldd	r25, Y+1	; 0x01
 95c:	15 d1       	rcall	.+554    	; 0xb88 <free>
__static_initialization_and_destruction_0():
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:23
 95e:	88 e3       	ldi	r24, 0x38	; 56
 960:	cd 3a       	cpi	r28, 0xAD	; 173
 962:	d8 07       	cpc	r29, r24
 964:	c1 f7       	brne	.-16     	; 0x956 <_GLOBAL__sub_D_a+0x8>
_GLOBAL__sub_D_a():
D:\Inkubator\Learning\SkinTemp_Isolation\Mikro_Sensor/Mikro_Sensor.ino:86
    b = 0;
}

void loop(){
  send_data();
}
 966:	df 91       	pop	r29
 968:	cf 91       	pop	r28
 96a:	08 95       	ret

0000096c <atol>:
atol():
 96c:	1f 93       	push	r17
 96e:	fc 01       	movw	r30, r24
 970:	99 27       	eor	r25, r25
 972:	88 27       	eor	r24, r24
 974:	bc 01       	movw	r22, r24
 976:	e8 94       	clt
 978:	11 91       	ld	r17, Z+
 97a:	10 32       	cpi	r17, 0x20	; 32
 97c:	e9 f3       	breq	.-6      	; 0x978 <atol+0xc>
 97e:	19 30       	cpi	r17, 0x09	; 9
 980:	10 f0       	brcs	.+4      	; 0x986 <atol+0x1a>
 982:	1e 30       	cpi	r17, 0x0E	; 14
 984:	c8 f3       	brcs	.-14     	; 0x978 <atol+0xc>
 986:	1b 32       	cpi	r17, 0x2B	; 43
 988:	49 f0       	breq	.+18     	; 0x99c <atol+0x30>
 98a:	1d 32       	cpi	r17, 0x2D	; 45
 98c:	41 f4       	brne	.+16     	; 0x99e <atol+0x32>
 98e:	68 94       	set
 990:	05 c0       	rjmp	.+10     	; 0x99c <atol+0x30>
 992:	12 d0       	rcall	.+36     	; 0x9b8 <__mulsi_const_10>
 994:	61 0f       	add	r22, r17
 996:	71 1d       	adc	r23, r1
 998:	81 1d       	adc	r24, r1
 99a:	91 1d       	adc	r25, r1
 99c:	11 91       	ld	r17, Z+
 99e:	10 53       	subi	r17, 0x30	; 48
 9a0:	1a 30       	cpi	r17, 0x0A	; 10
 9a2:	b8 f3       	brcs	.-18     	; 0x992 <atol+0x26>
 9a4:	3e f4       	brtc	.+14     	; 0x9b4 <atol+0x48>
 9a6:	90 95       	com	r25
 9a8:	80 95       	com	r24
 9aa:	70 95       	com	r23
 9ac:	61 95       	neg	r22
 9ae:	7f 4f       	sbci	r23, 0xFF	; 255
 9b0:	8f 4f       	sbci	r24, 0xFF	; 255
 9b2:	9f 4f       	sbci	r25, 0xFF	; 255
 9b4:	1f 91       	pop	r17
 9b6:	08 95       	ret

000009b8 <__mulsi_const_10>:
__mulsi_const_10():
 9b8:	59 2f       	mov	r21, r25
 9ba:	48 2f       	mov	r20, r24
 9bc:	37 2f       	mov	r19, r23
 9be:	26 2f       	mov	r18, r22
 9c0:	66 0f       	add	r22, r22
 9c2:	77 1f       	adc	r23, r23
 9c4:	88 1f       	adc	r24, r24
 9c6:	99 1f       	adc	r25, r25
 9c8:	66 0f       	add	r22, r22
 9ca:	77 1f       	adc	r23, r23
 9cc:	88 1f       	adc	r24, r24
 9ce:	99 1f       	adc	r25, r25
 9d0:	62 0f       	add	r22, r18
 9d2:	73 1f       	adc	r23, r19
 9d4:	84 1f       	adc	r24, r20
 9d6:	95 1f       	adc	r25, r21
 9d8:	66 0f       	add	r22, r22
 9da:	77 1f       	adc	r23, r23
 9dc:	88 1f       	adc	r24, r24
 9de:	99 1f       	adc	r25, r25
 9e0:	08 95       	ret

000009e2 <__prologue_saves__>:
__prologue_saves__():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2169
 9e2:	2f 92       	push	r2
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2170
 9e4:	3f 92       	push	r3
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2171
 9e6:	4f 92       	push	r4
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2172
 9e8:	5f 92       	push	r5
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2173
 9ea:	6f 92       	push	r6
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2174
 9ec:	7f 92       	push	r7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2175
 9ee:	8f 92       	push	r8
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2176
 9f0:	9f 92       	push	r9
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2177
 9f2:	af 92       	push	r10
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2178
 9f4:	bf 92       	push	r11
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2179
 9f6:	cf 92       	push	r12
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2180
 9f8:	df 92       	push	r13
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2181
 9fa:	ef 92       	push	r14
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2182
 9fc:	ff 92       	push	r15
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2183
 9fe:	0f 93       	push	r16
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2184
 a00:	1f 93       	push	r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2185
 a02:	cf 93       	push	r28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2186
 a04:	df 93       	push	r29
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2193
 a06:	cd b7       	in	r28, 0x3d	; 61
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2194
 a08:	de b7       	in	r29, 0x3e	; 62
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2195
 a0a:	ca 1b       	sub	r28, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2196
 a0c:	db 0b       	sbc	r29, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2197
 a0e:	cd bf       	out	0x3d, r28	; 61
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2198
 a10:	de bf       	out	0x3e, r29	; 62
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2211
 a12:	09 94       	ijmp

00000a14 <__epilogue_restores__>:
__epilogue_restores__():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2222
 a14:	2a 88       	ldd	r2, Y+18	; 0x12
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2223
 a16:	39 88       	ldd	r3, Y+17	; 0x11
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2224
 a18:	48 88       	ldd	r4, Y+16	; 0x10
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2225
 a1a:	5f 84       	ldd	r5, Y+15	; 0x0f
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2226
 a1c:	6e 84       	ldd	r6, Y+14	; 0x0e
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2227
 a1e:	7d 84       	ldd	r7, Y+13	; 0x0d
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2228
 a20:	8c 84       	ldd	r8, Y+12	; 0x0c
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2229
 a22:	9b 84       	ldd	r9, Y+11	; 0x0b
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2230
 a24:	aa 84       	ldd	r10, Y+10	; 0x0a
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2231
 a26:	b9 84       	ldd	r11, Y+9	; 0x09
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2232
 a28:	c8 84       	ldd	r12, Y+8	; 0x08
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2233
 a2a:	df 80       	ldd	r13, Y+7	; 0x07
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2234
 a2c:	ee 80       	ldd	r14, Y+6	; 0x06
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2235
 a2e:	fd 80       	ldd	r15, Y+5	; 0x05
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2236
 a30:	0c 81       	ldd	r16, Y+4	; 0x04
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2237
 a32:	1b 81       	ldd	r17, Y+3	; 0x03
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2238
 a34:	aa 81       	ldd	r26, Y+2	; 0x02
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2245
 a36:	b9 81       	ldd	r27, Y+1	; 0x01
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2246
 a38:	ce 0f       	add	r28, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2247
 a3a:	d1 1d       	adc	r29, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2248
 a3c:	cd bf       	out	0x3d, r28	; 61
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2249
 a3e:	de bf       	out	0x3e, r29	; 62
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2250
 a40:	ed 01       	movw	r28, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2263
 a42:	08 95       	ret

00000a44 <__tablejump2__>:
__tablejump2__():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 a44:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 a46:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 a48:	05 90       	lpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 a4a:	f4 91       	lpm	r31, Z
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 a4c:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 a4e:	09 94       	ijmp

00000a50 <malloc>:
malloc():
 a50:	0f 93       	push	r16
 a52:	1f 93       	push	r17
 a54:	cf 93       	push	r28
 a56:	df 93       	push	r29
 a58:	82 30       	cpi	r24, 0x02	; 2
 a5a:	91 05       	cpc	r25, r1
 a5c:	10 f4       	brcc	.+4      	; 0xa62 <malloc+0x12>
 a5e:	82 e0       	ldi	r24, 0x02	; 2
 a60:	90 e0       	ldi	r25, 0x00	; 0
 a62:	e0 91 27 39 	lds	r30, 0x3927	; 0x803927 <__flp>
 a66:	f0 91 28 39 	lds	r31, 0x3928	; 0x803928 <__flp+0x1>
 a6a:	30 e0       	ldi	r19, 0x00	; 0
 a6c:	20 e0       	ldi	r18, 0x00	; 0
 a6e:	b0 e0       	ldi	r27, 0x00	; 0
 a70:	a0 e0       	ldi	r26, 0x00	; 0
 a72:	30 97       	sbiw	r30, 0x00	; 0
 a74:	99 f4       	brne	.+38     	; 0xa9c <malloc+0x4c>
 a76:	21 15       	cp	r18, r1
 a78:	31 05       	cpc	r19, r1
 a7a:	09 f4       	brne	.+2      	; 0xa7e <malloc+0x2e>
 a7c:	4a c0       	rjmp	.+148    	; 0xb12 <malloc+0xc2>
 a7e:	28 1b       	sub	r18, r24
 a80:	39 0b       	sbc	r19, r25
 a82:	24 30       	cpi	r18, 0x04	; 4
 a84:	31 05       	cpc	r19, r1
 a86:	d8 f5       	brcc	.+118    	; 0xafe <malloc+0xae>
 a88:	8a 81       	ldd	r24, Y+2	; 0x02
 a8a:	9b 81       	ldd	r25, Y+3	; 0x03
 a8c:	61 15       	cp	r22, r1
 a8e:	71 05       	cpc	r23, r1
 a90:	89 f1       	breq	.+98     	; 0xaf4 <malloc+0xa4>
 a92:	fb 01       	movw	r30, r22
 a94:	82 83       	std	Z+2, r24	; 0x02
 a96:	93 83       	std	Z+3, r25	; 0x03
 a98:	fe 01       	movw	r30, r28
 a9a:	11 c0       	rjmp	.+34     	; 0xabe <malloc+0x6e>
 a9c:	40 81       	ld	r20, Z
 a9e:	51 81       	ldd	r21, Z+1	; 0x01
 aa0:	02 81       	ldd	r16, Z+2	; 0x02
 aa2:	13 81       	ldd	r17, Z+3	; 0x03
 aa4:	48 17       	cp	r20, r24
 aa6:	59 07       	cpc	r21, r25
 aa8:	e0 f0       	brcs	.+56     	; 0xae2 <malloc+0x92>
 aaa:	48 17       	cp	r20, r24
 aac:	59 07       	cpc	r21, r25
 aae:	99 f4       	brne	.+38     	; 0xad6 <malloc+0x86>
 ab0:	10 97       	sbiw	r26, 0x00	; 0
 ab2:	61 f0       	breq	.+24     	; 0xacc <malloc+0x7c>
 ab4:	12 96       	adiw	r26, 0x02	; 2
 ab6:	0c 93       	st	X, r16
 ab8:	12 97       	sbiw	r26, 0x02	; 2
 aba:	13 96       	adiw	r26, 0x03	; 3
 abc:	1c 93       	st	X, r17
 abe:	32 96       	adiw	r30, 0x02	; 2
 ac0:	cf 01       	movw	r24, r30
 ac2:	df 91       	pop	r29
 ac4:	cf 91       	pop	r28
 ac6:	1f 91       	pop	r17
 ac8:	0f 91       	pop	r16
 aca:	08 95       	ret
 acc:	00 93 27 39 	sts	0x3927, r16	; 0x803927 <__flp>
 ad0:	10 93 28 39 	sts	0x3928, r17	; 0x803928 <__flp+0x1>
 ad4:	f4 cf       	rjmp	.-24     	; 0xabe <malloc+0x6e>
 ad6:	21 15       	cp	r18, r1
 ad8:	31 05       	cpc	r19, r1
 ada:	51 f0       	breq	.+20     	; 0xaf0 <malloc+0xa0>
 adc:	42 17       	cp	r20, r18
 ade:	53 07       	cpc	r21, r19
 ae0:	38 f0       	brcs	.+14     	; 0xaf0 <malloc+0xa0>
 ae2:	a9 01       	movw	r20, r18
 ae4:	db 01       	movw	r26, r22
 ae6:	9a 01       	movw	r18, r20
 ae8:	bd 01       	movw	r22, r26
 aea:	df 01       	movw	r26, r30
 aec:	f8 01       	movw	r30, r16
 aee:	c1 cf       	rjmp	.-126    	; 0xa72 <malloc+0x22>
 af0:	ef 01       	movw	r28, r30
 af2:	f9 cf       	rjmp	.-14     	; 0xae6 <malloc+0x96>
 af4:	80 93 27 39 	sts	0x3927, r24	; 0x803927 <__flp>
 af8:	90 93 28 39 	sts	0x3928, r25	; 0x803928 <__flp+0x1>
 afc:	cd cf       	rjmp	.-102    	; 0xa98 <malloc+0x48>
 afe:	fe 01       	movw	r30, r28
 b00:	e2 0f       	add	r30, r18
 b02:	f3 1f       	adc	r31, r19
 b04:	81 93       	st	Z+, r24
 b06:	91 93       	st	Z+, r25
 b08:	22 50       	subi	r18, 0x02	; 2
 b0a:	31 09       	sbc	r19, r1
 b0c:	28 83       	st	Y, r18
 b0e:	39 83       	std	Y+1, r19	; 0x01
 b10:	d7 cf       	rjmp	.-82     	; 0xac0 <malloc+0x70>
 b12:	20 91 25 39 	lds	r18, 0x3925	; 0x803925 <__brkval>
 b16:	30 91 26 39 	lds	r19, 0x3926	; 0x803926 <__brkval+0x1>
 b1a:	23 2b       	or	r18, r19
 b1c:	41 f4       	brne	.+16     	; 0xb2e <malloc+0xde>
 b1e:	20 91 02 38 	lds	r18, 0x3802	; 0x803802 <__malloc_heap_start>
 b22:	30 91 03 38 	lds	r19, 0x3803	; 0x803803 <__malloc_heap_start+0x1>
 b26:	20 93 25 39 	sts	0x3925, r18	; 0x803925 <__brkval>
 b2a:	30 93 26 39 	sts	0x3926, r19	; 0x803926 <__brkval+0x1>
 b2e:	20 91 00 38 	lds	r18, 0x3800	; 0x803800 <__DATA_REGION_ORIGIN__>
 b32:	30 91 01 38 	lds	r19, 0x3801	; 0x803801 <__DATA_REGION_ORIGIN__+0x1>
 b36:	21 15       	cp	r18, r1
 b38:	31 05       	cpc	r19, r1
 b3a:	41 f4       	brne	.+16     	; 0xb4c <malloc+0xfc>
 b3c:	2d b7       	in	r18, 0x3d	; 61
 b3e:	3e b7       	in	r19, 0x3e	; 62
 b40:	40 91 04 38 	lds	r20, 0x3804	; 0x803804 <__malloc_margin>
 b44:	50 91 05 38 	lds	r21, 0x3805	; 0x803805 <__malloc_margin+0x1>
 b48:	24 1b       	sub	r18, r20
 b4a:	35 0b       	sbc	r19, r21
 b4c:	e0 91 25 39 	lds	r30, 0x3925	; 0x803925 <__brkval>
 b50:	f0 91 26 39 	lds	r31, 0x3926	; 0x803926 <__brkval+0x1>
 b54:	e2 17       	cp	r30, r18
 b56:	f3 07       	cpc	r31, r19
 b58:	a0 f4       	brcc	.+40     	; 0xb82 <malloc+0x132>
 b5a:	2e 1b       	sub	r18, r30
 b5c:	3f 0b       	sbc	r19, r31
 b5e:	28 17       	cp	r18, r24
 b60:	39 07       	cpc	r19, r25
 b62:	78 f0       	brcs	.+30     	; 0xb82 <malloc+0x132>
 b64:	ac 01       	movw	r20, r24
 b66:	4e 5f       	subi	r20, 0xFE	; 254
 b68:	5f 4f       	sbci	r21, 0xFF	; 255
 b6a:	24 17       	cp	r18, r20
 b6c:	35 07       	cpc	r19, r21
 b6e:	48 f0       	brcs	.+18     	; 0xb82 <malloc+0x132>
 b70:	4e 0f       	add	r20, r30
 b72:	5f 1f       	adc	r21, r31
 b74:	40 93 25 39 	sts	0x3925, r20	; 0x803925 <__brkval>
 b78:	50 93 26 39 	sts	0x3926, r21	; 0x803926 <__brkval+0x1>
 b7c:	81 93       	st	Z+, r24
 b7e:	91 93       	st	Z+, r25
 b80:	9f cf       	rjmp	.-194    	; 0xac0 <malloc+0x70>
 b82:	f0 e0       	ldi	r31, 0x00	; 0
 b84:	e0 e0       	ldi	r30, 0x00	; 0
 b86:	9c cf       	rjmp	.-200    	; 0xac0 <malloc+0x70>

00000b88 <free>:
free():
 b88:	cf 93       	push	r28
 b8a:	df 93       	push	r29
 b8c:	00 97       	sbiw	r24, 0x00	; 0
 b8e:	e9 f0       	breq	.+58     	; 0xbca <free+0x42>
 b90:	fc 01       	movw	r30, r24
 b92:	32 97       	sbiw	r30, 0x02	; 2
 b94:	12 82       	std	Z+2, r1	; 0x02
 b96:	13 82       	std	Z+3, r1	; 0x03
 b98:	a0 91 27 39 	lds	r26, 0x3927	; 0x803927 <__flp>
 b9c:	b0 91 28 39 	lds	r27, 0x3928	; 0x803928 <__flp+0x1>
 ba0:	ed 01       	movw	r28, r26
 ba2:	30 e0       	ldi	r19, 0x00	; 0
 ba4:	20 e0       	ldi	r18, 0x00	; 0
 ba6:	10 97       	sbiw	r26, 0x00	; 0
 ba8:	a1 f4       	brne	.+40     	; 0xbd2 <free+0x4a>
 baa:	20 81       	ld	r18, Z
 bac:	31 81       	ldd	r19, Z+1	; 0x01
 bae:	82 0f       	add	r24, r18
 bb0:	93 1f       	adc	r25, r19
 bb2:	20 91 25 39 	lds	r18, 0x3925	; 0x803925 <__brkval>
 bb6:	30 91 26 39 	lds	r19, 0x3926	; 0x803926 <__brkval+0x1>
 bba:	28 17       	cp	r18, r24
 bbc:	39 07       	cpc	r19, r25
 bbe:	09 f0       	breq	.+2      	; 0xbc2 <free+0x3a>
 bc0:	61 c0       	rjmp	.+194    	; 0xc84 <free+0xfc>
 bc2:	e0 93 25 39 	sts	0x3925, r30	; 0x803925 <__brkval>
 bc6:	f0 93 26 39 	sts	0x3926, r31	; 0x803926 <__brkval+0x1>
 bca:	df 91       	pop	r29
 bcc:	cf 91       	pop	r28
 bce:	08 95       	ret
 bd0:	ea 01       	movw	r28, r20
 bd2:	ce 17       	cp	r28, r30
 bd4:	df 07       	cpc	r29, r31
 bd6:	e8 f5       	brcc	.+122    	; 0xc52 <free+0xca>
 bd8:	4a 81       	ldd	r20, Y+2	; 0x02
 bda:	5b 81       	ldd	r21, Y+3	; 0x03
 bdc:	9e 01       	movw	r18, r28
 bde:	41 15       	cp	r20, r1
 be0:	51 05       	cpc	r21, r1
 be2:	b1 f7       	brne	.-20     	; 0xbd0 <free+0x48>
 be4:	e9 01       	movw	r28, r18
 be6:	ea 83       	std	Y+2, r30	; 0x02
 be8:	fb 83       	std	Y+3, r31	; 0x03
 bea:	49 91       	ld	r20, Y+
 bec:	59 91       	ld	r21, Y+
 bee:	c4 0f       	add	r28, r20
 bf0:	d5 1f       	adc	r29, r21
 bf2:	ec 17       	cp	r30, r28
 bf4:	fd 07       	cpc	r31, r29
 bf6:	61 f4       	brne	.+24     	; 0xc10 <free+0x88>
 bf8:	80 81       	ld	r24, Z
 bfa:	91 81       	ldd	r25, Z+1	; 0x01
 bfc:	02 96       	adiw	r24, 0x02	; 2
 bfe:	84 0f       	add	r24, r20
 c00:	95 1f       	adc	r25, r21
 c02:	e9 01       	movw	r28, r18
 c04:	88 83       	st	Y, r24
 c06:	99 83       	std	Y+1, r25	; 0x01
 c08:	82 81       	ldd	r24, Z+2	; 0x02
 c0a:	93 81       	ldd	r25, Z+3	; 0x03
 c0c:	8a 83       	std	Y+2, r24	; 0x02
 c0e:	9b 83       	std	Y+3, r25	; 0x03
 c10:	f0 e0       	ldi	r31, 0x00	; 0
 c12:	e0 e0       	ldi	r30, 0x00	; 0
 c14:	12 96       	adiw	r26, 0x02	; 2
 c16:	8d 91       	ld	r24, X+
 c18:	9c 91       	ld	r25, X
 c1a:	13 97       	sbiw	r26, 0x03	; 3
 c1c:	00 97       	sbiw	r24, 0x00	; 0
 c1e:	b9 f5       	brne	.+110    	; 0xc8e <free+0x106>
 c20:	2d 91       	ld	r18, X+
 c22:	3c 91       	ld	r19, X
 c24:	11 97       	sbiw	r26, 0x01	; 1
 c26:	cd 01       	movw	r24, r26
 c28:	02 96       	adiw	r24, 0x02	; 2
 c2a:	82 0f       	add	r24, r18
 c2c:	93 1f       	adc	r25, r19
 c2e:	20 91 25 39 	lds	r18, 0x3925	; 0x803925 <__brkval>
 c32:	30 91 26 39 	lds	r19, 0x3926	; 0x803926 <__brkval+0x1>
 c36:	28 17       	cp	r18, r24
 c38:	39 07       	cpc	r19, r25
 c3a:	39 f6       	brne	.-114    	; 0xbca <free+0x42>
 c3c:	30 97       	sbiw	r30, 0x00	; 0
 c3e:	51 f5       	brne	.+84     	; 0xc94 <free+0x10c>
 c40:	10 92 27 39 	sts	0x3927, r1	; 0x803927 <__flp>
 c44:	10 92 28 39 	sts	0x3928, r1	; 0x803928 <__flp+0x1>
 c48:	a0 93 25 39 	sts	0x3925, r26	; 0x803925 <__brkval>
 c4c:	b0 93 26 39 	sts	0x3926, r27	; 0x803926 <__brkval+0x1>
 c50:	bc cf       	rjmp	.-136    	; 0xbca <free+0x42>
 c52:	c2 83       	std	Z+2, r28	; 0x02
 c54:	d3 83       	std	Z+3, r29	; 0x03
 c56:	40 81       	ld	r20, Z
 c58:	51 81       	ldd	r21, Z+1	; 0x01
 c5a:	84 0f       	add	r24, r20
 c5c:	95 1f       	adc	r25, r21
 c5e:	c8 17       	cp	r28, r24
 c60:	d9 07       	cpc	r29, r25
 c62:	61 f4       	brne	.+24     	; 0xc7c <free+0xf4>
 c64:	4e 5f       	subi	r20, 0xFE	; 254
 c66:	5f 4f       	sbci	r21, 0xFF	; 255
 c68:	88 81       	ld	r24, Y
 c6a:	99 81       	ldd	r25, Y+1	; 0x01
 c6c:	48 0f       	add	r20, r24
 c6e:	59 1f       	adc	r21, r25
 c70:	40 83       	st	Z, r20
 c72:	51 83       	std	Z+1, r21	; 0x01
 c74:	8a 81       	ldd	r24, Y+2	; 0x02
 c76:	9b 81       	ldd	r25, Y+3	; 0x03
 c78:	82 83       	std	Z+2, r24	; 0x02
 c7a:	93 83       	std	Z+3, r25	; 0x03
 c7c:	21 15       	cp	r18, r1
 c7e:	31 05       	cpc	r19, r1
 c80:	09 f0       	breq	.+2      	; 0xc84 <free+0xfc>
 c82:	b0 cf       	rjmp	.-160    	; 0xbe4 <free+0x5c>
 c84:	e0 93 27 39 	sts	0x3927, r30	; 0x803927 <__flp>
 c88:	f0 93 28 39 	sts	0x3928, r31	; 0x803928 <__flp+0x1>
 c8c:	9e cf       	rjmp	.-196    	; 0xbca <free+0x42>
 c8e:	fd 01       	movw	r30, r26
 c90:	dc 01       	movw	r26, r24
 c92:	c0 cf       	rjmp	.-128    	; 0xc14 <free+0x8c>
 c94:	12 82       	std	Z+2, r1	; 0x02
 c96:	13 82       	std	Z+3, r1	; 0x03
 c98:	d7 cf       	rjmp	.-82     	; 0xc48 <free+0xc0>

00000c9a <realloc>:
realloc():
 c9a:	b0 e0       	ldi	r27, 0x00	; 0
 c9c:	a0 e0       	ldi	r26, 0x00	; 0
 c9e:	e2 e5       	ldi	r30, 0x52	; 82
 ca0:	f6 e0       	ldi	r31, 0x06	; 6
 ca2:	a1 ce       	rjmp	.-702    	; 0x9e6 <__prologue_saves__+0x4>
 ca4:	8c 01       	movw	r16, r24
 ca6:	00 97       	sbiw	r24, 0x00	; 0
 ca8:	41 f4       	brne	.+16     	; 0xcba <realloc+0x20>
 caa:	cb 01       	movw	r24, r22
 cac:	d1 de       	rcall	.-606    	; 0xa50 <malloc>
 cae:	8c 01       	movw	r16, r24
 cb0:	c8 01       	movw	r24, r16
 cb2:	cd b7       	in	r28, 0x3d	; 61
 cb4:	de b7       	in	r29, 0x3e	; 62
 cb6:	e0 e1       	ldi	r30, 0x10	; 16
 cb8:	af ce       	rjmp	.-674    	; 0xa18 <__epilogue_restores__+0x4>
 cba:	fc 01       	movw	r30, r24
 cbc:	e6 0f       	add	r30, r22
 cbe:	f7 1f       	adc	r31, r23
 cc0:	9c 01       	movw	r18, r24
 cc2:	22 50       	subi	r18, 0x02	; 2
 cc4:	31 09       	sbc	r19, r1
 cc6:	e2 17       	cp	r30, r18
 cc8:	f3 07       	cpc	r31, r19
 cca:	08 f4       	brcc	.+2      	; 0xcce <realloc+0x34>
 ccc:	99 c0       	rjmp	.+306    	; 0xe00 <realloc+0x166>
 cce:	d9 01       	movw	r26, r18
 cd0:	cd 91       	ld	r28, X+
 cd2:	dc 91       	ld	r29, X
 cd4:	11 97       	sbiw	r26, 0x01	; 1
 cd6:	c6 17       	cp	r28, r22
 cd8:	d7 07       	cpc	r29, r23
 cda:	90 f0       	brcs	.+36     	; 0xd00 <realloc+0x66>
 cdc:	c5 30       	cpi	r28, 0x05	; 5
 cde:	d1 05       	cpc	r29, r1
 ce0:	38 f3       	brcs	.-50     	; 0xcb0 <realloc+0x16>
 ce2:	ce 01       	movw	r24, r28
 ce4:	04 97       	sbiw	r24, 0x04	; 4
 ce6:	86 17       	cp	r24, r22
 ce8:	97 07       	cpc	r25, r23
 cea:	10 f3       	brcs	.-60     	; 0xcb0 <realloc+0x16>
 cec:	c6 1b       	sub	r28, r22
 cee:	d7 0b       	sbc	r29, r23
 cf0:	22 97       	sbiw	r28, 0x02	; 2
 cf2:	c1 93       	st	Z+, r28
 cf4:	d1 93       	st	Z+, r29
 cf6:	6d 93       	st	X+, r22
 cf8:	7c 93       	st	X, r23
 cfa:	cf 01       	movw	r24, r30
 cfc:	45 df       	rcall	.-374    	; 0xb88 <free>
 cfe:	d8 cf       	rjmp	.-80     	; 0xcb0 <realloc+0x16>
 d00:	5b 01       	movw	r10, r22
 d02:	ac 1a       	sub	r10, r28
 d04:	bd 0a       	sbc	r11, r29
 d06:	4c 01       	movw	r8, r24
 d08:	8c 0e       	add	r8, r28
 d0a:	9d 1e       	adc	r9, r29
 d0c:	a0 91 27 39 	lds	r26, 0x3927	; 0x803927 <__flp>
 d10:	b0 91 28 39 	lds	r27, 0x3928	; 0x803928 <__flp+0x1>
 d14:	51 2c       	mov	r5, r1
 d16:	41 2c       	mov	r4, r1
 d18:	f1 2c       	mov	r15, r1
 d1a:	e1 2c       	mov	r14, r1
 d1c:	10 97       	sbiw	r26, 0x00	; 0
 d1e:	31 f5       	brne	.+76     	; 0xd6c <realloc+0xd2>
 d20:	80 91 25 39 	lds	r24, 0x3925	; 0x803925 <__brkval>
 d24:	90 91 26 39 	lds	r25, 0x3926	; 0x803926 <__brkval+0x1>
 d28:	88 15       	cp	r24, r8
 d2a:	99 05       	cpc	r25, r9
 d2c:	09 f0       	breq	.+2      	; 0xd30 <realloc+0x96>
 d2e:	5c c0       	rjmp	.+184    	; 0xde8 <realloc+0x14e>
 d30:	46 16       	cp	r4, r22
 d32:	57 06       	cpc	r5, r23
 d34:	08 f0       	brcs	.+2      	; 0xd38 <realloc+0x9e>
 d36:	58 c0       	rjmp	.+176    	; 0xde8 <realloc+0x14e>
 d38:	80 91 00 38 	lds	r24, 0x3800	; 0x803800 <__DATA_REGION_ORIGIN__>
 d3c:	90 91 01 38 	lds	r25, 0x3801	; 0x803801 <__DATA_REGION_ORIGIN__+0x1>
 d40:	00 97       	sbiw	r24, 0x00	; 0
 d42:	41 f4       	brne	.+16     	; 0xd54 <realloc+0xba>
 d44:	8d b7       	in	r24, 0x3d	; 61
 d46:	9e b7       	in	r25, 0x3e	; 62
 d48:	40 91 04 38 	lds	r20, 0x3804	; 0x803804 <__malloc_margin>
 d4c:	50 91 05 38 	lds	r21, 0x3805	; 0x803805 <__malloc_margin+0x1>
 d50:	84 1b       	sub	r24, r20
 d52:	95 0b       	sbc	r25, r21
 d54:	e8 17       	cp	r30, r24
 d56:	f9 07       	cpc	r31, r25
 d58:	08 f0       	brcs	.+2      	; 0xd5c <realloc+0xc2>
 d5a:	52 c0       	rjmp	.+164    	; 0xe00 <realloc+0x166>
 d5c:	e0 93 25 39 	sts	0x3925, r30	; 0x803925 <__brkval>
 d60:	f0 93 26 39 	sts	0x3926, r31	; 0x803926 <__brkval+0x1>
 d64:	f9 01       	movw	r30, r18
 d66:	60 83       	st	Z, r22
 d68:	71 83       	std	Z+1, r23	; 0x01
 d6a:	a2 cf       	rjmp	.-188    	; 0xcb0 <realloc+0x16>
 d6c:	8d 91       	ld	r24, X+
 d6e:	9c 91       	ld	r25, X
 d70:	11 97       	sbiw	r26, 0x01	; 1
 d72:	12 96       	adiw	r26, 0x02	; 2
 d74:	6c 90       	ld	r6, X
 d76:	12 97       	sbiw	r26, 0x02	; 2
 d78:	13 96       	adiw	r26, 0x03	; 3
 d7a:	7c 90       	ld	r7, X
 d7c:	13 97       	sbiw	r26, 0x03	; 3
 d7e:	a8 15       	cp	r26, r8
 d80:	b9 05       	cpc	r27, r9
 d82:	59 f5       	brne	.+86     	; 0xdda <realloc+0x140>
 d84:	6c 01       	movw	r12, r24
 d86:	42 e0       	ldi	r20, 0x02	; 2
 d88:	c4 0e       	add	r12, r20
 d8a:	d1 1c       	adc	r13, r1
 d8c:	ca 14       	cp	r12, r10
 d8e:	db 04       	cpc	r13, r11
 d90:	20 f1       	brcs	.+72     	; 0xdda <realloc+0x140>
 d92:	ac 01       	movw	r20, r24
 d94:	4a 19       	sub	r20, r10
 d96:	5b 09       	sbc	r21, r11
 d98:	da 01       	movw	r26, r20
 d9a:	12 96       	adiw	r26, 0x02	; 2
 d9c:	15 97       	sbiw	r26, 0x05	; 5
 d9e:	80 f0       	brcs	.+32     	; 0xdc0 <realloc+0x126>
 da0:	62 82       	std	Z+2, r6	; 0x02
 da2:	73 82       	std	Z+3, r7	; 0x03
 da4:	40 83       	st	Z, r20
 da6:	51 83       	std	Z+1, r21	; 0x01
 da8:	d9 01       	movw	r26, r18
 daa:	6d 93       	st	X+, r22
 dac:	7c 93       	st	X, r23
 dae:	e1 14       	cp	r14, r1
 db0:	f1 04       	cpc	r15, r1
 db2:	71 f0       	breq	.+28     	; 0xdd0 <realloc+0x136>
 db4:	d7 01       	movw	r26, r14
 db6:	12 96       	adiw	r26, 0x02	; 2
 db8:	ed 93       	st	X+, r30
 dba:	fc 93       	st	X, r31
 dbc:	13 97       	sbiw	r26, 0x03	; 3
 dbe:	78 cf       	rjmp	.-272    	; 0xcb0 <realloc+0x16>
 dc0:	22 96       	adiw	r28, 0x02	; 2
 dc2:	8c 0f       	add	r24, r28
 dc4:	9d 1f       	adc	r25, r29
 dc6:	f9 01       	movw	r30, r18
 dc8:	80 83       	st	Z, r24
 dca:	91 83       	std	Z+1, r25	; 0x01
 dcc:	f3 01       	movw	r30, r6
 dce:	ef cf       	rjmp	.-34     	; 0xdae <realloc+0x114>
 dd0:	e0 93 27 39 	sts	0x3927, r30	; 0x803927 <__flp>
 dd4:	f0 93 28 39 	sts	0x3928, r31	; 0x803928 <__flp+0x1>
 dd8:	6b cf       	rjmp	.-298    	; 0xcb0 <realloc+0x16>
 dda:	48 16       	cp	r4, r24
 ddc:	59 06       	cpc	r5, r25
 dde:	08 f4       	brcc	.+2      	; 0xde2 <realloc+0x148>
 de0:	2c 01       	movw	r4, r24
 de2:	7d 01       	movw	r14, r26
 de4:	d3 01       	movw	r26, r6
 de6:	9a cf       	rjmp	.-204    	; 0xd1c <realloc+0x82>
 de8:	cb 01       	movw	r24, r22
 dea:	32 de       	rcall	.-924    	; 0xa50 <malloc>
 dec:	7c 01       	movw	r14, r24
 dee:	00 97       	sbiw	r24, 0x00	; 0
 df0:	39 f0       	breq	.+14     	; 0xe00 <realloc+0x166>
 df2:	ae 01       	movw	r20, r28
 df4:	b8 01       	movw	r22, r16
 df6:	07 d0       	rcall	.+14     	; 0xe06 <memcpy>
 df8:	c8 01       	movw	r24, r16
 dfa:	c6 de       	rcall	.-628    	; 0xb88 <free>
 dfc:	87 01       	movw	r16, r14
 dfe:	58 cf       	rjmp	.-336    	; 0xcb0 <realloc+0x16>
 e00:	10 e0       	ldi	r17, 0x00	; 0
 e02:	00 e0       	ldi	r16, 0x00	; 0
 e04:	55 cf       	rjmp	.-342    	; 0xcb0 <realloc+0x16>

00000e06 <memcpy>:
memcpy():
 e06:	fb 01       	movw	r30, r22
 e08:	dc 01       	movw	r26, r24
 e0a:	02 c0       	rjmp	.+4      	; 0xe10 <memcpy+0xa>
 e0c:	01 90       	ld	r0, Z+
 e0e:	0d 92       	st	X+, r0
 e10:	41 50       	subi	r20, 0x01	; 1
 e12:	50 40       	sbci	r21, 0x00	; 0
 e14:	d8 f7       	brcc	.-10     	; 0xe0c <memcpy+0x6>
 e16:	08 95       	ret

00000e18 <strcpy>:
strcpy():
 e18:	fb 01       	movw	r30, r22
 e1a:	dc 01       	movw	r26, r24
 e1c:	01 90       	ld	r0, Z+
 e1e:	0d 92       	st	X+, r0
 e20:	00 20       	and	r0, r0
 e22:	e1 f7       	brne	.-8      	; 0xe1c <strcpy+0x4>
 e24:	08 95       	ret

00000e26 <__do_global_dtors>:
__do_global_dtors():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2496
 e26:	10 e0       	ldi	r17, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2497
 e28:	cf e3       	ldi	r28, 0x3F	; 63
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2498
 e2a:	d0 e0       	ldi	r29, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2502
 e2c:	03 c0       	rjmp	.+6      	; 0xe34 <__do_global_dtors+0xe>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2508
 e2e:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2509
 e30:	09 de       	rcall	.-1006   	; 0xa44 <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2510
 e32:	21 96       	adiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2515
 e34:	c0 34       	cpi	r28, 0x40	; 64
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2516
 e36:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2521
 e38:	d1 f7       	brne	.-12     	; 0xe2e <__do_global_dtors+0x8>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 e3a:	f8 94       	cli

00000e3c <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega3/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 e3c:	ff cf       	rjmp	.-2      	; 0xe3c <__stop_program>
